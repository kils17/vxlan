
  grouping ip-access-list-grouping {

    // <protocol>
    leaf protocol {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type union {
        type uint8 {
          tailf:info "<0-255>;;A protocol number";
        }
        type enumeration {
          enum "ahp" {
            tailf:info "Authentication header protocol";
            value 51;
          }
          enum "eigrp" {
            tailf:info "Cisco's EIGRP routing protocol";
            value 88;
          }
          enum "esp" {
            tailf:info "Encapsulation security payload";
            value 50;
          }
          enum "gre" {
            tailf:info "Cisco's GRE tunneling";
            value 47;
          }
          enum "icmp" {
            tailf:info "Internet Control Message Protocol";
            value 1;
          }
          enum "igmp" {
            tailf:info "Internet Group Management Protocol";
            value 2;
          }
          enum "ip" {
            tailf:info "Any IP protocol";
            value 0;
          }
          enum "nos" {
            tailf:info "KA9Q NOS compatible IP over IP tunneling";
            value 94;
          }
          enum "ospf" {
            tailf:info "OSPF routing protocol";
            value 89;
          }
          enum "pcp" {
            tailf:info "Payload compression protocol";
            value 108;
          }
          enum "pim" {
            tailf:info "Protocol independent multicast";
            value 103;
          }
          enum "tcp" {
            tailf:info "Transmission Control Protocol";
            value 6;
          }
          enum "udp" {
            tailf:info "User Datagram Protocol";
            value 17;
          }
        }
      }
    }

    // <source>
    container source {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      choice source-choice {
        leaf host {
          tailf:info "A single source host";
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source address";
          }
        }
        leaf any {
          tailf:info "Any source address";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf address-and-prefix {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;Source network prefix";
          }
        }
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source network address";
          }
        }
        leaf addrgroup {
          tailf:info "Source address group";
          tailf:cli-incomplete-command;
          tailf:non-strict-leafref {
            path "/nx:object-group/ip/address/name";
          }
          type string {
            tailf:info "WORD;;Address group name";
          }
        }
      }
      leaf source-mask {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        when "../address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Source wildcard bits";
        }
      }
    }

    container packet-match-source {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-optional-in-sequence;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      when "../protocol = 'udp' or ../protocol = 'tcp'";
      uses ip-access-packet-match-grouping;
    }

    // <destination>
    choice destination-choice {
      leaf host {
        tailf:info "A single destination host";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination address";
        }
      }
      leaf any {
        tailf:info "Any destination address";
        type empty;
      }
      leaf address-and-prefix {
        tailf:cli-drop-node-name;
        type tailf:ipv4-address-and-prefix-length {
          tailf:info "A.B.C.D/LEN;;Destination network prefix";
        }
      }
      leaf address {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination network address";
        }
      }
      leaf addrgroup {
        tailf:info "Destination address group";
        tailf:non-strict-leafref {
          path "/nx:object-group/ip/address/name";
        }
        type string {
          tailf:info "WORD;;Address group name";
        }
      }
    }

    leaf dest-mask {
      tailf:cli-drop-node-name;
      when "../address";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Destination wildcard bits";
      }
    }

    leaf icmp-message-match {
      when "../protocol = 'icmp'" {
        tailf:dependency "../protocol";
      }
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      type union {
        type uint8 {
          tailf:info "<0-255>;;ICMP message type";
        }
        type enumeration {
          enum echo-reply {
            tailf:info "Echo reply";
            value 0;
          }
          enum echo {
            tailf:info "Echo (7)";
            value 8;
          }
          enum ttl-exceeded {
            tailf:info "TTL exceeded";
            value 11;
          }
          enum time-exceeded {
            tailf:info "All time exceededs";
          }
          enum port-unreachable {
            tailf:info "Port unreachable";
            value 3;
          }
          enum host-unreachable {
            tailf:info "Host unreachable";
          }
          enum unreachable {
            tailf:info "All unreachables";
          }
          enum packet-too-big {
            tailf:info "Fragmentation needed and DF set";
          }
          enum hop-limit {
            tailf:info "Hop limit exceeded in transit";
          }
          enum next-header {
            tailf:info "Parameter next header problems";
          }
          enum parameter-option {
            tailf:info "Parameter option problems";
          }
          enum parameter-problem {
            tailf:info "All parameter problems";
          }
          enum protocol-unreachable {
            tailf:info "Protocol unreachable";
          }
          enum administratively-prohibited {
            tailf:info "Administratively prohibited";
          }
          enum alternate-address {
            tailf:info "Alternate address";
          }
          enum conversion-error {
            tailf:info "Datagram conversion";
          }
          enum dod-host-prohibited {
            tailf:info "Host prohibited";
          }
          enum dod-net-prohibited {
            tailf:info "Net prohibited";
          }
          enum general-parameter-problem {
            tailf:info "Parameter problem";
          }
          enum host-isolated {
            tailf:info "Host isolated";
          }
          enum host-precedence-unreachable {
            tailf:info "Host unreachable for precedence";
          }
          enum host-redirect {
            tailf:info "Host redirect";
          }
          enum host-tos-redirect {
            tailf:info "Host redirect for TOS";
          }
          enum host-tos-unreachable {
            tailf:info "Host unreachable for TOS";
          }
          enum host-unknown {
            tailf:info "Host unknown";
          }
          enum information-reply {
            tailf:info "Information replies";
          }
          enum information-request {
            tailf:info "Information requests";
          }
          enum mask-reply {
            tailf:info "Mask replies";
          }
          enum mask-request {
            tailf:info "Mask requests";
          }
          enum mobile-redirect {
            tailf:info "Mobile host redirect";
          }
          enum net-redirect {
            tailf:info "Network redirect";
          }
          enum net-tos-redirect {
            tailf:info "Net redirect for TOS";
          }
          enum net-tos-unreachable {
            tailf:info "Network unreachable for TOS";
          }
          enum net-unreachable {
            tailf:info "Net unreachable";
          }
          enum network-unknown {
            tailf:info "Network unknown";
          }
          enum no-room-for-option {
            tailf:info "Parameter required but no room";
          }
          enum option-missing {
            tailf:info "Parameter required but not present";
          }
          enum precedence-unreachable {
            tailf:info "Precedence cutoff";
          }
          enum reassembly-timeout {
            tailf:info "Reassembly timeout";
          }
          enum router-advertisement {
            tailf:info "Router discovery advertisements";
          }
          enum router-solicitation {
            tailf:info "Router discovery solicitations";
          }
          enum traceroute {
            tailf:info "Traceroute";
          }
          enum source-quench {
            tailf:info "Source quenches";
          }
          enum source-route-failed {
            tailf:info "Source route failed";
          }
        }
      }
    }

    leaf icmp-message-code {
      when "../icmp-message-match" {
        tailf:dependency "../icmp-message-match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      type uint8 {
        tailf:info "<0-255>;;ICMP message code";
      }
    }

    leaf igmp-message-match {
      when "../protocol = 'igmp'" {
        tailf:dependency "../protocol";
      }
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum dvmrp {
          tailf:info "Distance Vector Multicast Routing Protocol";
        }
        enum host-query {
          tailf:info "Host query";
        }
        enum host-report {
          tailf:info "Host report";
        }
        enum pim {
          tailf:info "Protocol Independent Multicast";
        }
      }
    }

    uses ip-access-list-option-grouping;
  }

  grouping ipv6-access-list-grouping {
    // <protocol>
    leaf protocol {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type union {
        type uint8 {
          tailf:info "<0-255>;;A protocol number";
        }
        type enumeration {
          enum "ahp" {
            tailf:info "Authentication header protocol";
            value 51;
          }
          enum "eigrp" {
            tailf:info "Cisco's EIGRP routing protocol";
            value 88;
          }
          enum "esp" {
            tailf:info "Encapsulation security payload";
            value 50;
          }
          enum "gre" {
            tailf:info "Cisco's GRE tunneling";
            value 47;
          }
          enum "icmp" {
            tailf:info "Internet Control Message Protocol";
            value 58;
          }
          enum "ipv6" {
            tailf:info "Any IPv6 Protocol";
            value 41;
          }
          enum "sctp" {
            tailf:info "Stream Control Transmission Protocol";
            value 132;
          }
          enum "nos" {
            tailf:info "KA9Q NOS compatible IP over IP tunneling";
            value 94;
          }
          enum "ospf" {
            tailf:info "OSPF routing protocol";
            value 89;
          }
          enum "pcp" {
            tailf:info "Payload compression protocol";
            value 108;
          }
          enum "pim" {
            tailf:info "Protocol independent multicast";
            value 103;
          }
          enum "tcp" {
            tailf:info "Transmission Control Protocol";
            value 6;
          }
          enum "udp" {
            tailf:info "User Datagram Protocol";
            value 17;
          }
          enum "ip" {
            tailf:info "Any IPv6 Protocol";
          }
        }
      }
    }

    // <source>
    container source {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      choice source-choice {
        leaf host {
          tailf:info "A single source host";
          tailf:cli-incomplete-command;
          type inet:ipv6-address {
            tailf:info "A:B::C:D;;Source address";
          }
        }
        leaf any {
          tailf:info "Any source address";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf address-and-prefix {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type tailf:ipv6-address-and-prefix-length {
            tailf:info "A:B::C:D/LEN;;Source network prefix";
          }
        }
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv6-address {
            tailf:info "A:B::C:D;;Source network address";
          }
        }
        leaf addrgroup {
          tailf:info "Source address group";
          tailf:cli-incomplete-command;
          tailf:non-strict-leafref {
            path "/nx:object-group/ipv6/address/name";
          }
          type string {
            tailf:info "WORD;;Address group name";
          }
        }
      }
      leaf source-mask {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        when "../address";
        type inet:ipv6-address {
          tailf:info "A:B::C:D;;Source wildcard bits";
        }
      }
    }

    container packet-match-source {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-optional-in-sequence;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      when "../protocol = 'udp' or ../protocol = 'tcp' or ../protocol = 'sctp'";
      uses ip-access-packet-match-grouping;
    }

    // <destination>
    choice destination-choice {
      leaf host {
        tailf:info "A single destination host";
        type inet:ipv6-address {
          tailf:info "A:B::C:D;;Destination address";
        }
      }
      leaf any {
        tailf:info "Any destination address";
        type empty;
      }
      leaf address-and-prefix {
        tailf:cli-drop-node-name;
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "A:B::C:D/LEN;;Destination network prefix";
        }
      }
      leaf address {
        tailf:cli-drop-node-name;
        type inet:ipv6-address {
          tailf:info "A:B::C:D;;Destination network address";
        }
      }
      leaf addrgroup {
        tailf:info "Destination address group";
        tailf:non-strict-leafref {
          path "/nx:object-group/ipv6/address/name";
        }
        type string {
          tailf:info "WORD;;Address group name";
        }
      }
    }

    leaf dest-mask {
      tailf:cli-drop-node-name;
      when "../address";
      type inet:ipv6-address {
        tailf:info "A:B::C:D;;Destination wildcard bits";
      }
    }

    leaf icmpv6-message-type {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      when "../protocol = 'icmp'" {
        tailf:dependency "../protocol";
      }
      type enumeration {
        enum echo-request {
          tailf:info "Echo request (ping)";
          value 128;
        }
        enum echo-reply {
          tailf:info "Echo reply";
          value 129;
        }
        enum router-solicitation {
          tailf:info "Neighbor discovery router solicitations";
          value 133;
        }
        enum router-advertisement {
          tailf:info "Neighbor discovery router advertisements";
          value 134;
        }
        enum nd-ns {
          tailf:info "Neighbor discovery neighbor solicitations";
          value 135;
        }
        enum nd-na {
          tailf:info "Neighbor discovery neighbor advertisements";
          value 136;
        }
        enum mld-query {
          tailf:info "Multicast Listener Discovery Query";
          value 130;
        }
        enum mld-reduction {
          tailf:info "Multicast Listener Discovery Reduction";
        }
        enum mld-report {
          tailf:info "Multicast Listener Discovery Report";
          value 131;
        }
        enum mldv2 {
          tailf:info "Multicast Listener Discovery Protocol";
        }
        enum hop-limit {
          tailf:info "Hop limit exceeded in transit";
        }
        enum next-header {
          tailf:info "Parameter next header problems";
        }
        enum packet-too-big {
          tailf:info "Packet too big";
        }
        enum parameter-option {
          tailf:info "Parameter option problems";
        }
        enum parameter-problem {
          tailf:info "All parameter problems";
        }
        enum no-route {
          tailf:info "No route to destination";
        }
        enum port-unreachable {
          tailf:info "Port unreachable";
        }
        enum unreachable {
          tailf:info "All unreachable";
        }
        enum router-renumbering {
          tailf:info "All router renumbering";
        }
        enum time-exceeded {
          tailf:info "All time exceededs";
        }
        enum header {
          tailf:info "Parameter header problems";
        }
        enum destination-unreachable {
          tailf:info "Destination address is unreachable";
        }
        enum renum-command {
          tailf:info "Router renumbering command";
        }
        enum renum-result {
          tailf:info "Router renumbering result";
        }
        enum renum-seq-number {
          tailf:info "Router renumbering sequence number reset";
        }
      }
    }

    uses ip-access-list-option-grouping;
  }


  // ip access-list * /
  // ipv6 access-list * /
  grouping ip-access-list-common-grouping {
    // ip access-list * / fragments
    leaf fragments {
      tailf:info "Optimize fragments rule installation";
      type enumeration {
        enum "deny-all";
        enum "permit-all";
      }
    }

    // ip access-list * / statistics
    container statistics {
      tailf:info "Enable per-entry statistics for the ACL";
      leaf per-entry {
        tailf:info "Collect stats for each ACL entry";
        type empty;
      }
    }
  }

  // ip
  // vrf context * / ip
  grouping ip-grouping {

    // ip domain-list *
    // vrf context * / ip domain-list *
    list domain-list {
      tailf:info "Add additional domain names";
      tailf:cli-suppress-mode;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Enter a domain (Max Size 64)";
          length "1..64";
        }
      }
    }

    // ip domain-name
    leaf domain-name {
      tailf:info "Specify default domain name";
      type string {
        tailf:info "WORD;;Enter the default domain (Max Size 64)";
        length "1..64";

      }
    }

    // ip name-server *
    container name-server {
      tailf:cli-compact-syntax;
      leaf-list servers {
        tailf:info "Specify nameserver address";
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        tailf:cli-disallow-value "use-vrf";
        tailf:cli-replace-all;
        tailf:cli-remove-before-change;
        ordered-by user;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Enter an IPv4 address";
          }
          type inet:ipv6-address {
            tailf:info "A:B::C:D;;Enter an IPv6 address";
          }
        }
      }
    }

    container name-server-vrf {
      tailf:cli-drop-node-name;
      list name-server {
        tailf:info "Specify nameserver address";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        nx:prefix-key-leaf-list "use-vrf";
        tailf:cli-remove-before-change;
        key use-vrf;
        leaf use-vrf {
          tailf:info "Display per-VRF information";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
          }
        }
        leaf-list servers {
          tailf:info "Specify nameserver address";
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          tailf:cli-disallow-value "use-vrf";
          tailf:cli-replace-all;
          ordered-by user;
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter an IPv4 address";
            }
            type inet:ipv6-address {
              tailf:info "A:B::C:D;;Enter an IPv6 address";
            }
          }
        }
      }
    }

    // ip route *
    container route {
      tailf:info "Route information";

      // ip route * static
      container static {
        tailf:info "Static route based configuration";
        tailf:cli-diff-dependency "/nx:feature/bfd";
        when "/nx:feature/bfd" {
          tailf:dependency "/nx:feature/bfd";
        }
        // ip route * static bfd
        container bfd {
          tailf:info "Enable bfd detection on static route";
          //  skip: ethernet      Ethernet IEEE 802.3z
          list port-channel {
            tailf:info "Port Channel interface";
            tailf:cli-suppress-mode;
            tailf:cli-incomplete-command;
            tailf:cli-allow-join-with-key {
              tailf:cli-display-joined;
            }
            key id;
            leaf id {
              type string {
                pattern "[0-9]+(\\.[0-9]+)?";
                tailf:info "<1-4096>[.<1-4096>];;Port Channel number [.Sub-interface number]";
              }
            }
            leaf-list next-hop {
              tailf:cli-drop-node-name;
              tailf:cli-list-syntax;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
              }
            }
          }
          // ip route * static bfd Vlan *
          list Vlan {
            tailf:info "Vlan interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-diff-dependency "/nx:feature/interface-vlan";
            when "/nx:feature/interface-vlan" {
              tailf:dependency "/nx:feature/interface-vlan";
            }
            tailf:cli-incomplete-command;
            tailf:cli-allow-join-with-key {
              tailf:cli-display-joined;
            }
            key id;
            leaf id {
              tailf:info "<1-4094>;;Vlan interface number";
              type uint16 {
                range "1..4094";
              }
            }
            leaf-list next-hop {
              tailf:cli-drop-node-name;
              tailf:cli-list-syntax;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
              }
            }
          }
          list Ethernet {
            tailf:info "Ethernet IEEE 802.3z";
            tailf:cli-allow-join-with-key {
              tailf:cli-display-joined;
            }
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                pattern "([0-9])+/([0-9])+(/([0-9])+)?(\\.[0-9]+)?";
                tailf:info "<1-66>/<1-128>;;Slot number/Port number";
              }
            }
            leaf-list next-hop {
              tailf:cli-drop-node-name;
              tailf:cli-list-syntax;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
              }
            }
          }
        }
      }

      list ip-route-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        key "prefix-mask next-hop";
        leaf prefix-mask {
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;IP prefix and network mask length "
              +"in format x.x.x.x/m";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
            }
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/LEN  IP next-hop prefix in format i.i.i.i/m";
            }
            type enumeration {
              enum Null0 {
                tailf:info "Null interface";
              }
            }
            type string {
              tailf:info "Vlan interface";
              pattern "[Vv]lan[0-9]+";
            }
          }
        }
        uses ip-route-options-grouping;
      }
      list ip-route-interface-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        key "prefix-mask interface next-hop";
        leaf prefix-mask {
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;IP prefix and network mask length "
              +"in format x.x.x.x/m";
          }
        }
        leaf interface {
          nx:case-insensitive-type;
          type string {
            tailf:info "WORD;;Interface name";
            pattern "(([Ee]thernet)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
            }
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/LEN  IP next-hop prefix in format i.i.i.i/m";
            }
          }
        }
        uses ip-route-options-grouping;
      }
      list ip-route-vrf-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        key "prefix-mask next-hop vrf";
        leaf prefix-mask {
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;IP prefix and network mask length "
              +"in format x.x.x.x/m";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
            }
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/LEN  IP next-hop prefix in format i.i.i.i/m";
            }
            type enumeration {
              enum Null0 {
                tailf:info "Null interface";
              }
            }
            type string {
              tailf:info "Vlan interface";
              pattern "[Vv]lan[0-9]+";
            }
          }
        }
        leaf vrf {
          tailf:info "VRF for next-hop if different from this vrf";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
            length "1..32";
          }
        }
        uses ip-route-options-grouping;
      }
      list ip-route-interface-vrf-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        key "prefix-mask interface next-hop vrf";
        leaf prefix-mask {
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;IP prefix and network mask length "
              +"in format x.x.x.x/m";
          }
        }
        leaf interface {
          nx:case-insensitive-type;
          type string {
            tailf:info "WORD;;Interface name";
            pattern "(([Ee]thernet)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
            }
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/LEN  IP next-hop prefix in format i.i.i.i/m";
            }
          }
        }
        leaf vrf {
          tailf:info "VRF for next-hop if different from this vrf";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
            length "1..32";
          }
        }
        uses ip-route-options-grouping;
      }
    }

    // ip mroute *
    container mroute {
      tailf:info "Configure multicast RPF static route";
      list ip-mroute-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key "prefix-mask next-hop";
        leaf prefix-mask {
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;IP prefix and network mask length "
              +"in format x.x.x.x/m";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
            }
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/LEN  IP next-hop prefix in format i.i.i.i/m";
            }
          }
        }
      }
    }

    // ip multicast
    container multicast {
      tailf:info "Configure IP multicast global parameters";
      container multipath {
        tailf:info "Configure ECMP multicast load splitting";
        tailf:cli-incomplete-no;
        choice hash-or-disable-choice {
          leaf legacy {
            tailf:info "Configure hash based on source and group";
            type empty;
          }
          container s-g-hash {
            tailf:info "Configure hash based on source and group address";
            leaf next-hop-based {
              tailf:info "Configure hash based on source, group, next-hop address";
              type empty;
            }
          }
          leaf none {
            tailf:info "Disable ECMP multicast load splitting";
            type empty;
          }
        }
        leaf nbm {
          tailf:info "Configure NBM controlled RPF interface";
          tailf:cli-diff-dependency "../resilient" {
            tailf:cli-trigger-on-set;
          }
          type empty;
        }
        leaf resilient {
          tailf:info "Configure resilient RPF interface";
          tailf:cli-diff-dependency "../nbm" {
            tailf:cli-trigger-on-set;
          }
          type empty;
        }
      }
      container multipath-enable {
        tailf:cli-drop-node-name;
        leaf multipath {
          tailf:info "Configure ECMP multicast load splitting";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    container icmp-errors {
      tailf:info "ICMP unreachable/TTL-exceeded/param-prob messages";
      leaf source-interface {
        tailf:info "Configure source-address for applications";
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        nx:case-insensitive-type;
        type string;
      }
    }

    uses ip-pim-grouping;
  }

  grouping iface-choice-grouping {
    choice iface-choice {
      leaf Ethernet {
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:info "Ethernet IEEE 802.3z";
        type string {
        }
      }
      leaf loopback {
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:info "Loopback interface";
        tailf:non-strict-leafref {
          path "/nx:interface/loopback/name";
        }
        type uint16 {
          tailf:info "<0-1023>;;Virtual interface number";
        }
      }
      leaf port-channel {
        tailf:info "Port Channel interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/nx:interface/port-channel/name";
        }
        type string {
          tailf:info "<1-4096>;;Port Channel number";
        }
      }
    }
  }

  grouping rp-candidate-grouping {
    container rp-candidate {
      tailf:info "Configure router as a Rendezvous Point (RP) candidate";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      uses iface-choice-grouping;
      choice policy-choice {
        leaf group-list {
          tailf:info "Group range list";
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;Prefix of group range";
          }
        }
        leaf prefix-list {
          tailf:info "Prefix List policy for Candidate RP";
          type string {
            tailf:info "WORD;;Name of prefix-list (Max Size 63)";
          }
        }
        leaf route-map {
          tailf:info "Group range policy for Candidate RP";
          type string {
            tailf:info "WORD;;Route-map name (Max Size 63)";
          }
        }
      }
    }
    leaf rp-candidate-policy {
      tailf:info "Specify policy for filtering RP candidate messages";
      type string {
        tailf:info "WORD;;Route-map name (Max Size 63)";
      }
    }
  }

  grouping forward-listen-grouping {
    choice fwd-lstn-choice {
      leaf forward {
        tailf:info "Forward Auto-RP messages";
        tailf:cli-full-command;
        type empty;
      }
      leaf listen {
        tailf:info "Listen to Auto-RP messages";
        tailf:cli-full-command;
        type empty;
      }
      container forward-and-listen {
        tailf:cli-drop-node-name;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf forward {
          tailf:info "Forward Auto-RP messages";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf listen {
          tailf:info "Listen to Auto-RP messages";
          type empty;
        }
      }
    }
  }

  grouping ip-pim-grouping {
    container pim {
      tailf:info "PIM global configuration commands";
      tailf:cli-diff-dependency "/nx:feature/pim";
      list anycast-rp {
        tailf:cli-suppress-mode;
        key "address rp";
        leaf address {
          tailf:info "A.B.C.D;;Address for the Anycast-RP address";
          type inet:ipv4-address;
        }
        leaf rp {
          tailf:info "A.B.C.D;;Address of RP in the Anycast-RP set";
          type inet:ipv4-address;
        }
      }
      // Seems not configurable on many devices
      // leaf auto-enable {
      //   tailf:info "Auto-enable configure on the vrf";
      //   tailf:cli-boolean-no;
      //   default true;
      //   type boolean;
      // }
      container auto-rp {
        tailf:info "Auto-RP protocol RP-distribution configuration";
        uses forward-listen-grouping;
        container mapping-agent {
          tailf:info "Configures router as an Auto-RP RP-mapping agent";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          uses iface-choice-grouping;
          leaf scope {
            tailf:info "Configure the scope of Auto-RP Discovery messages";
            default 32;
            type uint8 {
              tailf:info "<1-255>;;TTL value for scope";
            }
          }
        }
        leaf mapping-agent-policy {
          tailf:info "Specify policy for filtering Mapping Agent messages";
          type string {
            tailf:info "WORD;;Route-map name (Max Size 63)";
          }
        }
        uses rp-candidate-grouping;
      }

      leaf bidir-rp-limit {
        tailf:info "Configures maximum Bidir RPs for IPv4 PIM in this VRF";
        default 6;
        type uint8 {
          tailf:info "<0-8>;;Set limit for Bidir RPs permitted in IPv4 PIM";
        }
      }

      // ip pim bsr
      container bsr {
        tailf:info "Bootstrap protocol RP-distribution configuration";
        container bsr-candidate {
          tailf:info "Configure router as a Bootstrap Router candidate";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          uses iface-choice-grouping;
          leaf hash-len {
            tailf:info "Hash mask length used in Bootstrap messages";
            default 30;
            type uint8 {
              tailf:info "<0-32>;;Hash mask length value";
            }
          }
          leaf priority {
            tailf:info "BSR priority used in Bootstrap messages";
            default 64;
            type uint8 {
              tailf:info "<1-255>  BSR priority value";
            }
          }
          leaf interval {
            tailf:info "Bootstrap message transmission interval";
            default 60;
            type uint16 {
              tailf:info "<1-65535>;;Interval in seconds";
            }
          }
        }
        leaf bsr-policy {
          tailf:info "Specify policy for filtering BSR messages";
          type string {
            tailf:info "WORD;;Route-map name (Max Size 63)";
          }
        }
        uses forward-listen-grouping;
        uses rp-candidate-grouping;
      }

      container bsr-candidate {
        tailf:info "Configure router as a Bootstrap Router candidate";
      }
      // ip pim bfd
      leaf bfd {
        tailf:info "Enable / Disable BFD for all PIM interfaces in the VRF";
        tailf:cli-diff-dependency "/nx:feature/bfd";
        type empty;
      }

      leaf flush-routes {
        tailf:info "Remove routes when restarting PIM";
        type empty;
      }

      leaf log-neighbor-changes {
        tailf:info "Log up/down PIM neighbor transitions";
        type empty;
      }

      leaf pre-build-spt {
        tailf:info "Pre construct PIM trees for all known (S,G)s";
        type empty;
      }

      // ip pim register-policy
      choice register-policy-choice {
        leaf register-policy {
          tailf:info "Specify policy for receiving Register messages";
          tailf:cli-full-command;
          tailf:cli-full-no;
          type string {
            tailf:info "WORD;;A route-map name (Max Size 63)";
          }
        }
        container register-policy-prefix-list {
          tailf:cli-drop-node-name;
          container register-policy {
            tailf:info "Specify policy for receiving Register messages";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            leaf prefix-list {
              tailf:info "Prefix List policy for Registers";
              type string {
                tailf:info "WORD;;Prefix-list name (Max Size 63)";
              }
            }
          }
        }
      }

      // ip pim register-rate-limit
      leaf register-rate-limit {
        tailf:info "Rate limit for PIM data registers";
        type uint16 {
          tailf:info "<1-65535>;;Packets per second";
        }
      }

      // ip pim register-until-stop
      leaf register-until-stop {
        tailf:info "Send Data Registers till Register Stop is received";
        type empty;
      }

      // ip pim register-source
      leaf register-source {
        tailf:info "Configure source address for Register messages";
        type string {
          tailf:info "WORD;;Name of interface";
        }
      }

      // ip pim rp-address *
      list rp-address {
        tailf:info "Configure static RP for group range";
        key ip-address;
        tailf:cli-suppress-mode;
        tailf:cli-incomplete-command;
        tailf:cli-recursive-delete;
        tailf:cli-delete-when-empty;
        // ip pim rp-address * ip-address
        leaf ip-address {
          tailf:info "IP address of router which is RP for group range";
          type inet:ipv4-address {
            tailf:info "<inet:ipv4-address>;;IP address of router which is RP f"
              +"or group range";
          }
        }
        // ip pim rp-address * group-list *
        list group-list {
          tailf:info "Group range for static RP";
          key group-range-prefix;
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-delete-when-empty;
          // ip pim rp-address * group-list * group-range-prefix
          leaf group-range-prefix {
            tailf:info "Group range prefix";
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "<tailf:ipv4-address-and-prefix-length>;;Group range"
                +" prefix";
            }
          }
          // ip pim rp-address * group-list * bidir
          leaf bidir {
            tailf:info "Group range is treated in PIM bidirectional mode";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          // ip pim rp-address * group-list * override
          leaf override {
            tailf:info "RP address will override the dynamically learnt RPs";
            type empty;
          }
        }
        // ip pim rp-address * prefix-list *
        container prefix-list {
          tailf:info "Prefix List policy for static RP";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-diff-delete-before "../group-list";
          // ip pim rp-address * prefix-list * prefix-list-name
          leaf prefix-list-name {
            tailf:cli-drop-node-name;
            tailf:info "Prefix-list name (Max Size 63)";
            type string {
              tailf:info "<string>;;Prefix-list name (Max Size 63)";
              length "1..63";
            }
          }
          // ip pim rp-address * prefix-list * bidir
          leaf bidir {
            tailf:info "Group range is treated in PIM bidirectional mode";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          // ip pim rp-address * prefix-list * override
          leaf override {
            tailf:info "RP address will override the dynamically learnt RPs";
            type empty;
          }
        }
        // ip pim rp-address * route-map *
        container route-map {
          tailf:info "Route Map policy for static RP";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-diff-delete-before "../group-list";
          tailf:cli-diff-delete-before "../prefix-list";
          // ip pim rp-address * route-map * route-map-name
          leaf route-map-name {
            tailf:info "Route-map name (Max Size 63)";
            tailf:cli-drop-node-name;
            type string {
              tailf:info "<string>;;Route-map name (Max Size 63)";
              length "1..63";
            }
          }
          // ip pim rp-address * route-map * bidir
          leaf bidir {
            tailf:info "Group range is treated in PIM bidirectional mode";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          // ip pim rp-address * route-map * override
          leaf override {
            tailf:info "RP address will override the dynamically learnt RPs";
            type empty;
          }
        }
      }
      // Skip: 'ip pim rp-candidate'
      // Skip: 'ip pim send-rp-announce'
      // Skip: 'ip pim send-rp-discovery'
      // Skip: 'ip pim sg-expiry-timer'
      // Skip: 'ip pim sparse'
      // Skip: 'ip pim spt-threshold'
      // ip pim ssm
      container ssm {
        tailf:info "Source Specific Multicast (SSM) groups";
        // ip pim ssm
        choice ssm-choice {
          // ip pim ssm prefix-list
          leaf prefix-list {
            tailf:info "Group range prefix-list policy for SSM range";
            type string {
              tailf:info "<string>;;A prefix-list name (Max Size 63)";
              length "1..63";
            }
          }
          // ip pim ssm range
          container range {
            tailf:info "Configure explicit group ranges";
            // ip pim ssm range
            choice range-choice {
              // ip pim ssm range list-of-group
              leaf-list list-of-group {
                tailf:info "List of group range prefix";
                tailf:cli-drop-node-name;
                tailf:cli-flat-list-syntax;
                type tailf:ipv4-address-and-prefix-length {
                  tailf:info "<tailf:ipv4-address-and-prefix-length>;;List of"
                    +" group range prefix";
                }
              }
              // ip pim ssm range none
              leaf none {
                tailf:info "Remove all SSM group ranges";
                type empty;
              }
            }
          }
          // ip pim ssm route-map
          leaf route-map {
            tailf:info "Group range route-map policy for SSM range";
            type string {
              tailf:info "<string>;;A route-map name (Max Size 63)";
              length "1..63";
            }
          }
        }
      }

      // ip pim state-limit
      leaf state-limit {
        tailf:info "Configures State limit";
        type uint32 {
          tailf:info "<1-4294967295>;Maximum (*,G)/(S,G) entries allowed in this VRF";
        }
      }

      // Skip: 'ip pim strict-rfc-compliant'
      // Skip: 'ip pim use-shared-tree-only'
    }

  }

  grouping ipv6-grouping {

    // ipv6 route *
    container route {
      tailf:info "Configure IPv6 unicast static route";
      list ipv6-route-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        key "prefix-mask next-hop";
        leaf prefix-mask {
          type tailf:ipv6-address-and-prefix-length {
            tailf:info "A:B::C:D/LEN;;IPv6 prefix format: xxxx:xxxx/ml, xxxx:"
              +"xxxx::/ml, xxxx::xx/128";
          }
        }
        leaf interface {
          tailf:cli-optional-in-sequence;
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          nx:case-insensitive-type;
          type string {
            tailf:info "WORD;;Interface name";
            pattern "(([Ee]thernet)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv6-address;
            type tailf:ipv6-address-and-prefix-length;
            type enumeration {
              enum Null0 {
                tailf:info "Null interface";
              }
            }
          }
        }
        uses ip-route-options-grouping;
      }
      list ipv6-route-vrf-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        tailf:cli-diff-delete-before "../ipv6-route-vrf-list";
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        key "prefix-mask next-hop vrf";
        leaf prefix-mask {
          type tailf:ipv6-address-and-prefix-length {
            tailf:info "A:B::C:D/LEN;;IPv6 prefix format: xxxx:xxxx/ml, xxxx:"
              +"xxxx::/ml, xxxx::xx/128";
          }
        }
        leaf interface {
          tailf:cli-optional-in-sequence;
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          nx:case-insensitive-type;
          type string {
            tailf:info "WORD;;Interface name";
            pattern "(([Ee]thernet)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv6-address;
            type tailf:ipv6-address-and-prefix-length;
            type enumeration {
              enum Null0 {
                tailf:info "Null interface";
              }
            }
          }
        }
        leaf vrf {
          tailf:info "VRF for next-hop if different from this vrf";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
            length "1..32";
          }
        }
        uses ip-route-options-grouping;
      }

      // ipv6 route * static
      container static {
        tailf:info "Static route based configuration";
        tailf:cli-diff-dependency "/nx:feature/bfd";
        when "/nx:feature/bfd" {
          tailf:dependency "/nx:feature/bfd";
        }
        container bfd {
          tailf:info "Enable bfd detection on static route";
          list Vlan {
            tailf:info "Vlan interface";
            tailf:cli-suppress-mode;
            tailf:cli-diff-dependency "/nx:feature/interface-vlan";
            when "/nx:feature/interface-vlan" {
              tailf:dependency "/nx:feature/interface-vlan";
            }
            tailf:cli-allow-join-with-key {
              tailf:cli-display-joined;
            }
            key "id next-hop";
            leaf id {
              tailf:info "<1-4094>;;Vlan interface number";
              type uint16 {
                range "1..4094";
              }
            }
            leaf next-hop {
              type inet:ipv6-address {
                tailf:info "A:B::C:D;;IPv6 next-hop address in format aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh, aaaa::bbbb";
              }
            }
          }
          list Ethernet {
            tailf:info "Ethernet IEEE 802.3z";
            tailf:cli-suppress-mode;
            tailf:cli-allow-join-with-key {
              tailf:cli-display-joined;
            }
            key "name next-hop";
            leaf name {
              type string {
                pattern "([0-9])+/([0-9])+(/([0-9])+)?(\\.[0-9]+)?";
                tailf:info "<1-66>/<1-128>;;Slot number/Port number";
              }
            }
            leaf next-hop {
              type inet:ipv6-address {
                tailf:info "A:B::C:D;;IPv6 next-hop address in format aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh, aaaa::bbbb";
              }
            }
          }
          list port-channel {
            tailf:info "Port Channel interface";
            tailf:cli-suppress-mode;
            tailf:cli-allow-join-with-key {
              tailf:cli-display-joined;
            }
            key "id next-hop";
            leaf id {
              type string {
                tailf:info "<1-4096>;;Port Channel number";
                pattern "[0-9]+(\\.[0-9]+)?";
              }
            }
            leaf next-hop {
              type inet:ipv6-address {
                tailf:info "A:B::C:D;;IPv6 next-hop address in format aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh, aaaa::bbbb";
              }
            }
          }
        }
      }
    }

    container pim {
      tailf:info "PIM6 global configuration commands";
      tailf:cli-diff-delete-before "/nx:feature/pim6" {
        tailf:cli-when-target-delete;
      }
      tailf:cli-diff-set-after "/nx:feature/pim6" {
        tailf:cli-when-target-set;
      }
      container ssm {
        tailf:info "Source Specific Multicast (SSM) groups";
        choice rm-or-range {
          container range-none {
            tailf:cli-drop-node-name;
            container range {
              tailf:info "Configure explicit group ranges";
              leaf none {
                tailf:info "Remove all SSM group ranges";
                type empty;
              }
            }
          }
          leaf-list range {
            tailf:info "Configure explicit group ranges";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            tailf:cli-disallow-value "none";
            type inet:ipv6-prefix;
          }
          leaf route-map {
            tailf:info "Group range policy for SSM range";
            type string {
              tailf:info "WORD;;A route-map name (Max Size 63)";
            }
          }
        }
      }
    }
  }

  grouping line-access-class-grouping {
    list access-class {
      tailf:info "Specify access control for packets";
      tailf:cli-suppress-mode;
      key direction;
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;List name (Max Size 64)";
          length "1..64";
        }
      }
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Inbound packets";
          }
          enum out {
            tailf:info "Outbound packets";
          }
        }
      }
    }
  }

  // line vty
  // line console
  grouping line-grouping {

    // line vty * / exec-timeout
    leaf exec-timeout {
      tailf:info "Configure exec timeout";
      type uint32 {
        tailf:info "<0-525600>;;Enter timeout in minutes, 0 to disable";
        range "0..525600";
      }
    }

    uses line-access-class-grouping;

    container ipv6 {
      tailf:info "Configure IPv6 features";
      uses line-access-class-grouping;
    }

    container privilege {
      tailf:info "Change privilege level for line";
      leaf level {
        tailf:info "Assign default privilege level for line";
        type uint8 {
          tailf:info "<0-15>;;Default privilege level for line";
          range "0..15";
        }
      }
    }
  }

  // vdc *
  // vdc resource template *
  grouping vdc-grouping {

    // vdc * / limit-resource
    container limit-resource {
      tailf:info "Resource configuration";
      leaf-list module-type {
        tailf:info "Controls which type of modules are allowed in this vdc";
        tailf:cli-flat-list-syntax;
        type module-type;
      }
      container anycast_bundleid {
        tailf:info "Set anycast bundle id resource limits";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum anycast bundle ids to allocate";
          type enumeration {
            enum "0" {
              tailf:info "<0-0>;;Only maximum is supported";
            }
          }
        }
        leaf maximum {
          tailf:info "Maximum anycast bundle ids to allocate";
          type uint16 {
            tailf:info "<0-64>;;Maximum anycast switch id value";
          }
        }
      }
      container vlan {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }

      container monitor-session {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container monitor-rbs-filter {
        tailf:info "Rule Based SPAN Filters";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum RBS filter to allocate";
          type uint16 {
            tailf:info "<0-16>;;Minimum RBS filter value";
            range "0..16";
          }
        }
        leaf maximum {
          tailf:info "Maximum RBS filter to allocate";
          type uint16 {
            tailf:info "<0-16>;;Maximum RBS filter value";
            range "0..16";
          }
        }
      }
      container monitor-rbs-product {
        tailf:info "Rule Based SPAN Products";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum RBS product to allocate";
          type uint16 {
            tailf:info "<0-16>;;Minimum RBS product value";
            range "0..16";
          }
        }
        leaf maximum {
          tailf:info "Maximum RBS product to allocate";
          type uint16 {
            tailf:info "<0-16>;;Maximum RBS product value";
            range "0..16";
          }
        }
      }
      container monitor-session-erspan-dst {
        tailf:info "Monitor erspan destination session";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum monitor erspan-dst session to allocate";
          type uint16 {
            tailf:info "<0-23>;;Minimum monitor erspan-dst session value";
            range "0..23";
          }
        }
        leaf maximum {
          tailf:info "Maximum monitor erspan-dst session to allocate";
          type uint16 {
            tailf:info "<0-23>;;Maximum monitor erspan-dst session value";
            range "0..23";
          }
        }
      }
      container monitor-session-extended {
        tailf:info "Monitor local/erspan-source session";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum extended monitor session to allocate";
          type uint16 {
            tailf:info "<0-16>;;Minimum extended monitor session value";
            range "0..16";
          }
        }
        leaf maximum {
          tailf:info "Maximum extended monitor session to allocate";
          type uint16 {
            tailf:info "<0-16>;;Maximum extended monitor session value";
            range "0..16";
          }
        }
      }
      container monitor-session-inband-src {
        tailf:info "Monitor inband source";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum monitor inband source to allocate";
          type uint16 {
            tailf:info "<0-1>;;Minimum monitor inband source value";
            range "0..1";
          }
        }
        leaf maximum {
          tailf:info "Maximum monitor inband source to allocate";
          type uint16 {
            tailf:info "<0-1>;;Maximum monitor inband source value";
            range "0..1";
          }
        }
      }
      container monitor-session-mx-exception-src {
        tailf:info "Monitor Mx module exception source";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum monitor exception source to allocate";
          type uint16 {
            tailf:info "<0-1>;;Minimum monitor exception source value";
            range "0..1";
          }
        }
        leaf maximum {
          tailf:info "Maximum monitor exception source to allocate";
          type uint16 {
            tailf:info "<0-1>;;Maximum monitor exception source value";
            range "0..1";
          }
        }
      }
      container vrf {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container vrf-session {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container port-channel {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container u4route-mem {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container u6route-mem {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container m4route-mem {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container m6route-mem {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container vni_bd {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
    }
  }

  grouping aaa-group-local-grouping {
    leaf group {
      tailf:info "Specify server groups to redirect the accounting logs";
      tailf:cli-full-command;
      type string {
        length "1..127";
      }
    }

    leaf local {
      tailf:info "Use local accounting";
      tailf:cli-full-command;
      tailf:cli-boolean-no;
      default "true";
      type boolean;
    }
  }

  // interface ethernet * /
  // interface mgmt * /
  grouping interface-eth-and-mgmt-grouping {
    container lldp {
      tailf:info "Configure Interface LLDP parameters";
      tailf:cli-diff-dependency "/nx:feature/lldp";

      // interface * / no lldp transmit
      leaf transmit {
        tailf:info "Enable LLDP transmission on interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / no lldp receive
      leaf receive {
        tailf:info "Enable LLDP reception on interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      container tlv-set {
        tailf:info "LLDP TLV configuration for interface";
        leaf management-address {
          tailf:info "Management address to be sent in management-tlv of LLDPDU.";
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address in dotted decimal format i.i.i.i";
            }
            type inet:ipv6-address {
              tailf:info "A:B::C:D;;IPv6 address";
            }
          }
        }
        choice vlan-or-id {
          leaf vlan {
            tailf:info "VLAN-id whose SVI IP address should be used as management"
              +"adrress in management-tlv of LLDPDU. Default is native VLAN.";
            type empty;
          }
          container vlan-id {
            tailf:cli-incomplete-command;
            tailf:cli-drop-node-name;
            leaf vlan {
              tailf:info "VLAN-id whose SVI IP address should be used as management"
                +"adrress in management-tlv of LLDPDU. Default is native VLAN.";
              type uint16 {
                tailf:info "<1-4094>;;Vlan-id within range of 1-4094";
                range "1..4094";
              }
            }
          }
        }
      }
    }
    // interface * / cdp
    container cdp {
      tailf:info "Configure CDP interface parameters";
      leaf enable {
        tailf:info "Enable/disable CDP on the interface";
        type boolean;
        default true;
        tailf:cli-boolean-no;
      }
    }
    uses interface-l2port-common-grouping;
  }

  // class-map type control-plane * match exception ip
  // class-map type control-plane * match exception ipv6
  grouping class-map-match-exception-ip-grouping {
    container icmp {
      tailf:info "ICMP packets";
      leaf redirect {
        tailf:info "Send redirected packets back to sender";
        type empty;
      }
      leaf unreachable {
        tailf:info "Send unreachable packets back to sender";
        type empty;
      }
    }
    container multicast {
      tailf:info "Multicast traffic";
      leaf directly-connected-sources {
        tailf:info "Directly connected sources";
        type empty;
      }
      leaf rpf-failure {
        tailf:info "Failure in RPF check";
        type empty;
      }
    }
    leaf municast {
      tailf:info "IP/IPv6 unicast packets with multicast MAC";
      type empty;
    }
    leaf option {
      tailf:info "Match IP/IPv6 option packets";
      type empty;
    }
    container unicast {
      tailf:info "Unicast traffic";
      leaf rpf-failure {
        tailf:info "Unicast packets failed in RPF check";
        type empty;
      }
    }
  }

  grouping feature-set-grouping {
    leaf fabric {
      tailf:info "FABRIC";
      type empty;
    }
    leaf fabricpath {
      tailf:info "FABRICPATH";
      type empty;
    }
    leaf fcoe {
      tailf:info "FCOE";
      type empty;
    }
    leaf fex {
      tailf:info "FEX";
      type empty;
    }
    leaf mpls {
      tailf:info "MPLS";
      type empty;
    }
    leaf virtualization {
      tailf:info "VIRTUALIZATION";
      type empty;
    }
  }

  grouping vlan-bd-config-grouping {
    container ip {
      tailf:info "Configure IP features";
      container igmp {
        tailf:info "IGMP configuration commands";
        container snooping-disable {
          tailf:cli-drop-node-name;
          leaf snooping {
            tailf:info "Configures IGMP Snooping";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
        }
        container snooping {
          tailf:info "Configures IGMP Snooping";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list access-group {
            tailf:info "IGMP access-group";
            tailf:cli-suppress-mode;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-delete-when-empty;
            key interface;
            leaf interface {
              tailf:cli-expose-key-name;
              nx:case-insensitive-type;
              type string {
                tailf:info "<name>;;Specify interface for filtering (Ethernet or port-channel)";
                pattern "(([Ee]thernet)|([Pp]ort-channel))[0-9/\\.]+";
              }
            }
            choice prefix-key-choice {
              leaf prefix-list {
                tailf:info "IPv4 Prefix-List Policy";
                tailf:cli-prefix-key;
                type string {
                  tailf:info "WORD;;Policy Name Name (Max Size 63)";
                  length "1..63";
                }
              }
              leaf route-map {
                tailf:info "Route-Map Policy";
                tailf:cli-prefix-key;
                type string {
                  tailf:info "WORD;;Policy Name Name (Max Size 63)";
                  length "1..63";
                }
              }
            }
          }
          container access-group-leaf {
            tailf:cli-drop-node-name;
            leaf access-group {
              tailf:info "Configures filter policy for groups mentioned in route-map";
              tailf:alt-name "access-group";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Route-map name (Max Size 63)";
              }
            }
          }
          leaf explicit-tracking {
            tailf:info "Configures Explicit Host tracking for "
              +"vlan";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf fast-leave {
            tailf:info "Configures Fast leave for the vlan";
            tailf:cli-full-command;
            type empty;
          }
          leaf last-member-query-interval {
            tailf:info "Configures interval between group-"
              +"specific Query transmissions";
            tailf:cli-full-command;
            type uint8 {
              range "1..25";
              tailf:info "<1-25>  Interval in seconds "
                +"(Default value is 1)";
            }
            default "1";
          }
          leaf link-local-groups-suppression {
            tailf:info "Configures Vlan link-local groups "
              +"suppression";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          container mrouter {
            tailf:info "Configures static multicast router "
              +"interface";
            container "interface" {
              tailf:info "Specify interface for "
                +"static-mrouter";
              list Ethernet {
                tailf:info "Ethernet IEEE 802.3z";
                tailf:cli-allow-join-with-key {
                  tailf:cli-display-joined;
                }
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  type string {
                    pattern "([0-9])+/([0-9])+(/([0-9])+)?(\\.[0-9]+)?";
                    tailf:info "<1-66>/<1-128>;;Slot number/Port number";
                  }
                }
              }
              list port-channel {
                tailf:info "Port Channel interface";
                tailf:cli-allow-join-with-key {
                  tailf:cli-display-joined;
                }
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  tailf:cli-diff-dependency "/nx:interface/port-channel" {
                    tailf:cli-trigger-on-set;
                  }
                  type string {
                    tailf:info "<1-4096>;;Port Channel number";
                    pattern "[0-9]+(\\.[0-9]+)?";
                  }
                }
              }
            }
          }
          list static-group {
            tailf:info "Configures static group membership";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key group;
            leaf group {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Group IP Address";
              }
            }
            container "interface" {
              tailf:info "Specify interface for "
                +"static-mrouter";
              list Ethernet {
                tailf:info "Ethernet IEEE 802.3z";
                tailf:cli-allow-join-with-key {
                  tailf:cli-display-joined;
                }
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  type string {
                    pattern "([0-9])+/([0-9])+(/([0-9])+)?(\\.[0-9]+)?";
                    tailf:info "<1-66>/<1-128>;;Slot number/Port number";
                  }
                }
              }
              list port-channel {
                tailf:info "Port Channel interface";
                tailf:cli-allow-join-with-key {
                  tailf:cli-display-joined;
                }
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  tailf:non-strict-leafref {
                    path "/nx:interface/port-channel/name";
                  }
                  type string {
                    tailf:info "<1-4096>;;Port Channel number";
                    pattern "[0-9]+(\\.[0-9]+)?";
                  }
                }
              }
            }
          }
          // Note spelling in the below two: optimised vs optimise
          choice spelling-choice {
            default optimise-multicast-flood;
            leaf optimise-multicast-flood {
              tailf:info "Configures Optimised Multicast Flood (OMF) on the VLAN";
              tailf:cli-boolean-no;
              default true;
              type boolean;
            }
            leaf optimised-multicast-flood {
              tailf:info "Configures Optimised Multicast Flood (OMF) on the VLAN";
              tailf:cli-boolean-no;
              default true;
              type boolean;
            }
          }
          container proxy {
            tailf:info "Configures IGMP snooping proxy";
            container general-queries {
              tailf:info "Configures proxy for general-queries";
              leaf mrt {
                tailf:info "Configure max-response-time for the switch's proxy general-queries";
                default 5;
                type uint8 {
                  tailf:info "<1-25>;;MRT in seconds";
                }
              }
            }
          }
          container proxy-leave {
            tailf:info "Proxy Leave";
            leaf use-group-address {
              tailf:info "Use group address for proxy leave";
              type empty;
            }
          }
          // vlan configuration * / ip igmp snooping querier
          leaf querier {
            tailf:info "Enables snooping querier";
            type inet:ipv4-address;
          }
          leaf querier-timeout {
            tailf:info "Configures querier timeout for IGMPv2";
            default 255;
            type uint16 {
              tailf:info "<1-65535>;;Time in seconds";
            }
          }
          leaf query-interval {
            tailf:info "Configures interval between query transmission";
            default 125;
            type uint16 {
              tailf:info "<1-18000>;;Interval in seconds";
            }
          }
          leaf query-max-response-time {
            tailf:info "Configures MRT for query messages";
            default 10;
            type uint8 {
              tailf:info "<1-25>;;Time in seconds";
            }
          }
          container report-flood {
            tailf:info "Configures Report flooding on a VLAN";
            leaf all {
              tailf:info "Flood on ALL active ports of VLAN";
              type empty;
            }
            list interface {
              tailf:info "Specify interface for report flooding";
              tailf:cli-suppress-mode;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                nx:case-insensitive-type;
                type string {
                  tailf:info "<name>;;Specify interface for report flooding (Ethernet or port-channel)";
                  pattern "(([Ee]thernet)|([Pp]ort-channel))[0-9/\\.]+";
                }
              }
            }
          }
          list report-policy {
            tailf:info "IGMP Report Policy";
            tailf:cli-suppress-mode;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-delete-when-empty;
            key interface;
            leaf interface {
              tailf:cli-expose-key-name;
              nx:case-insensitive-type;
              type string {
                tailf:info "<name>;;Specify interface for filtering (Ethernet or port-channel)";
                pattern "(([Ee]thernet)|([Pp]ort-channel))[0-9/\\.]+";
              }
            }
            choice prefix-key-choice {
              leaf prefix-list {
                tailf:info "IPv4 Prefix-List Policy";
                tailf:cli-prefix-key;
                type string {
                  tailf:info "WORD;;Policy Name Name (Max Size 63)";
                  length "1..63";
                }
              }
              leaf route-map {
                tailf:info "Route-Map Policy";
                tailf:cli-prefix-key;
                type string {
                  tailf:info "WORD;;Policy Name Name (Max Size 63)";
                  length "1..63";
                }
              }
            }
          }
          leaf report-suppression {
            tailf:info "Configures IGMPv1/IGMPv2 Report Suppression for the VLAN/BD";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf robustness-variable {
            tailf:info "Configures RFC defined Robustness Variable";
            default 2;
            type uint8 {
              tailf:info "<1-7>;;Count value";
            }
          }
          leaf startup-query-count {
            tailf:info "Configures number of queries sent at startup";
            type uint8 {
              tailf:info "<1-10>;;Count value";
            }
          }
          leaf startup-query-interval {
            tailf:info "Configures query interval at startup";
            type uint16 {
              tailf:info "<1-18000>;;Interval in seconds";
            }
          }
          leaf group-timeout {
            tailf:info "Configures group membership timeout in VLAN/BD";
            type union {
              type uint16 {
                tailf:info "<1-10080>;;Timeout in minutes";
              }
              type enumeration {
                enum "never" {
                  tailf:info "Never expire ports from group membership";
                }
              }
            }
          }
          leaf v3-report-suppression {
            tailf:info "Configures IGMPv3 Report Suppression and Proxy Reporting for the VLAN/BD";
            type empty;
          }
          leaf version {
            tailf:info "Configures IGMP version number for VLAN/BD";
            nx:trim-default-in-show;
            default 3;
            type uint8 {
              tailf:info "<2-3>;Version number value";
            }
          }
        }
      }
    }

    // vlan * / service-policy
    container service-policy {
      tailf:info "Configure service policy for an interface";
      // interface * / service-policy type
      container type {
        tailf:info "Specify the type of this policy";
        // interface * / service-policy type qos
        container qos {
          tailf:info "Qos policy";
          // interface * / service-policy type qos input
          container input {
            tailf:info "Input Service Policy";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:non-strict-leafref {
                path "/nx:policy-map/type/qos/name";
              }
              type policy-map-name-type;
            }
            leaf no-stats {
              tailf:info "Disable statistics for this policy";
              type empty;
            }
          }
          // interface * / service-policy type qos output
          container output {
            tailf:info "Output Service Policy";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:non-strict-leafref {
                path "/nx:policy-map/type/qos/name";
              }
              type policy-map-name-type;
            }
            leaf no-stats {
              tailf:info "Disable statistics for this policy";
              type empty;
            }
          }
        }
      }
    }

  }

  grouping isis-spf-interval-grouping {
    leaf max-wait {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      type uint32 {
        tailf:info "<50-120000>;;Maximum wait between trigger and SPF com"
          +"putation (milli-secs)";
        range "50..120000";
      }
    }
    leaf init-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<50-120000>;;Initial wait between trigger and SPF com"
          +"putation (milli-secs)";
        range "50..120000";
      }
    }
    leaf second-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<50-120000>;;Second wait between trigger and SPF comp"
          +"utation (milli-secs)";
        range "50..120000";
      }
    }
  }

  grouping isis-lsp-gen-interval-grouping {
    leaf max-wait {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      type uint32 {
        tailf:info "<50-120000>;;Maximum wait between trigger and LSP gen"
          +"eration (milli-secs)";
        range "50..120000";
      }
    }
    leaf init-wait {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<50-120000>;;Initial wait between trigger and LSP gen"
          +"eration (milli-secs)";
        range "50..120000";
      }
    }
    leaf second-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<50-120000>;;Second wait used in LSP generation (mill"
          +"i-secs) during backoff";
        range "50..120000";
      }
    }
  }

  grouping eigrp-interface-config-list-grouping {
    list eigrp {
      tailf:info "EIGRP interface configuration commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "/nx:feature/eigrp";
      key id;
      leaf id {
        tailf:info "WORD;;Process tag (Max Size 20)";
        tailf:non-strict-leafref {
          path "/nx:router/eigrp/id";
        }
        type string {
          length "1..20";
        }
      }
    }
  }

  grouping eigrp-route-or-prefix-list-grouping {
    list eigrp {
      tailf:info "EIGRP interface configuration commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "/nx:feature/eigrp";
      key "id direction";
      leaf id {
        tailf:info "WORD;;Process tag (Max Size 20)";
        tailf:non-strict-leafref {
          path "/nx:router/eigrp/id";
        }
        type string {
          length "1..20";
        }
      }
      choice route-or-prefix-choice {
        leaf prefix-list {
          tailf:info "Use a prefix-list";
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          type string {
            tailf:info "WORD;;Reference to prefix-list name";
          }
        }
        leaf route-map {
          tailf:info "Use a route-map";
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          tailf:non-strict-leafref {
            path "/nx:route-map/name";
          }
          type string {
            tailf:info "WORD;;Route-map name (Max Size 63)";
          }
        }
      }
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Filter incoming routing updates";
          }
          enum "out" {
            tailf:info "Filter outgoing routing updates";
          }
        }
      }
    }
  }

  grouping lifetime-grouping {
    leaf local {
      tailf:info "Specify time in local timezone";
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type empty;
    }
    leaf start-time {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type string {
        tailf:info "WORD;;HH:MM:SS Time to start <0-23>:<0-59>:<0-59> (Max Size 8)";
        pattern "[0-9]+:[0-9]+:[0-9]+";
      }
    }
    leaf start-month {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type short-month-type;
    }
    leaf start-day {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<1-31>;Day of the month to start";
        range "1..31";
      }
    }
    leaf start-year {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint16 {
        tailf:info "<1993-2035>;;Year to start";
        range "1993..2035";
      }
    }
    choice lifetime-choice {
      case end-explicit-time {
        leaf end-time {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;HH:MM:SS Time to end <0-23>:<0-59>:<0-59> (Max Size 8)";
            pattern "[0-9]+:[0-9]+:[0-9]+";
          }
        }
        leaf end-month {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type short-month-type;
        }
        leaf end-day {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-31>;Day of the month to end";
            range "1..31";
          }
        }
        leaf end-year {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1993-2035>;;Year to end";
            range "1993..2035";
          }
        }
      }
      leaf duration {
        tailf:info "Set key lifetime duration";
        type uint32 {
          tailf:info "<1-2147483646>;;Duration in seconds";
        }
      }
      leaf infinite {
        tailf:info "Never Expires";
        type empty;
      }
    }
  }

  grouping queue-limit-grouping {
    choice limit-choice {
      case count {
        leaf count {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          must "../unit";
          type uint32 {
            tailf:info "<1-83886080>;;Queue size in packets/bytes/kbytes/mbytes/ms/us";
            range "1..83886080";
          }
        }
        // must be set if the count is set
        leaf unit {
          tailf:cli-drop-node-name;
          type enumeration {
            enum bytes {
              tailf:info "Bytes";
            }
            enum kbytes {
              tailf:info "Kilo bytes";
            }
            enum mbytes {
              tailf:info "Mega bytes";
            }
            enum ms {
              tailf:info "Milli second(s)";
            }
            enum packets {
              tailf:info "Packets";
            }
            enum us {
              tailf:info "Micro second(s)";
            }
          }
        }
      }
      case percent {
        leaf percent {
          tailf:info "Specify queue size in Percentage";
          type uint8 {
            tailf:info "<1-100>;;Queue size in percentage of total tx/rx buffer size";
            range "1..100";
          }
        }
      }
    }
  }

  grouping random-detect-grouping {
    container minimum-threshold {
      tailf:info "Specify minimum threshold for WRED";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-flatten-container;
      choice threshold-choice {
        case count {
          leaf count {
            tailf:cli-incomplete-command;
            tailf:cli-drop-node-name;
            must "../unit";
            type uint32 {
              tailf:info "<1-52428800>;;Minimum threshold value";
            }
          }
          // must be set if the count is set
          leaf unit {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum bytes {
                tailf:info "Bytes";
              }
              enum kbytes {
                tailf:info "Kilo bytes";
              }
              enum mbytes {
                tailf:info "Mega bytes";
              }
            }
          }
        }
        leaf percent {
          tailf:info "Specify thresholds in percent";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-100>;;Minimum threshold percent of queue size";
          }
        }
      }
    }
    container maximum-threshold {
      tailf:info "Specify maximum threshold for WRED";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-flatten-container;
      choice threshold-choice {
        case count {
          leaf count {
            tailf:cli-incomplete-command;
            tailf:cli-drop-node-name;
            must "../unit";
            type uint32 {
              tailf:info "<1-52428800>;;Maximum threshold value";
            }
          }
          // must be set if the count is set
          leaf unit {
            tailf:cli-drop-node-name;
            type enumeration {
              enum bytes {
                tailf:info "Bytes";
              }
              enum kbytes {
                tailf:info "Kilo bytes";
              }
              enum mbytes {
                tailf:info "Mega bytes";
              }
            }
          }
        }
        leaf percent {
          tailf:info "Specify thresholds in percent";
          type uint8 {
            tailf:info "<1-100>;;Maximum threshold percent of queue size";
          }
        }
      }
    }
  }

  grouping itu-t-grouping {
    leaf ql {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum exact { tailf:info " Specifies the exact QL to send"; }
        enum highest { tailf:info "Specifies an upper limit on the QL to be sent"; }
        enum lowest { tailf:info "Specifies a lower limit on the QL to be sent"; }
      }
    }
    container itu-t {
      tailf:info "ITU-T options";
      tailf:cli-flatten-container;
      leaf option {
        tailf:info "ITU-T options";
        tailf:cli-incomplete-command;
        type enumeration {
          enum 1 {
            tailf:info "ITU-T QL option 1";
          }
          enum 2 {
            tailf:info "ITU-T QL option 2";
          }
        }
      }
    }
    leaf option1-value {
      tailf:cli-drop-node-name;
      when "../itu-t/option = '1'" {
        tailf:dependency "../itu-t/option";
      }
      nx:enum-alias "DNU" {

      }
      type enumeration {
        enum DNU { tailf:info "This signal should not be used for synchronization"; }
        enum EEC1 { tailf:info "ITU-T Option 1: Ethernet equipment clock"; }
        enum PRC { tailf:info " ITU-T Option 1: Primary reference clock"; }
        enum PRTC { tailf:info "ITU-T Option 1: Primary reference timing clock"; }
        enum SEC { tailf:info " ITU-T Option 1: SONET equipment clock"; }
        enum SSU-A { tailf:info " ITU-T Option 1: Type I or V slave clock"; }
        enum SSU-B { tailf:info " ITU-T Option 1: Type IV slave clock"; }
        enum eEEC { tailf:info "ITU-T Option 1: Enhanced ethernet equipment clock"; }
        enum ePRTC { tailf:info "TU-T Option 1: Enhanced primary reference timing clock"; }
      }
    }
    leaf generation {
      tailf:info "ITU-T QL option 2 generation";
      tailf:cli-incomplete-command;
      when "../itu-t/option = '2'" {
        tailf:dependency "../itu-t/option";
      }
      type enumeration {
        enum 1 { tailf:info "ITU-T QL option 2 generation 1"; }
        enum 2 { tailf:info "ITU-T QL option 2 generation 2"; }
      }
    }
    leaf option2-value {
      tailf:cli-drop-node-name;
      when "../itu-t/option = '2'" {
        tailf:dependency "../itu-t/option";
      }
      nx:enum-alias "DUS" {

      }
      type itu-t-option2-type;
    }
    leaf highest {
      tailf:info "Specifies an upper limit on the QL to be sent";
      when "../ql = 'lowest'" {
        tailf:dependency "../ql";
      }
      nx:enum-alias "DUS" {

      }
      type itu-t-option2-type;
    }
  }

  grouping tcam-region-grouping {
    container region {
      tailf:info "Configure tcam region";
      container arp-ether-with-double-wide {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf arp-ether {
          tailf:info "Ingress ARP / L2 Ethertype table size";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          type tcam-size-type;
        }
        leaf double-wide {
          type empty;
        }
      }
      leaf arp-ether {
        tailf:info "Ingress ARP / L2 Ethertype table size";
        tailf:cli-full-command;
        type tcam-size-type;
      }
      leaf copp {
        tailf:info "Ingress COPP size";
        type tcam-size-type;
      }
      leaf e-qos {
        tailf:info "Egress IPV4 QoS size";
        type tcam-size-type;
      }
      leaf e-racl {
        tailf:info "Egress IPV4 RACL size";
        type tcam-size-type;
      }
      leaf ipv6-racl {
        tailf:info "IPV6 RACL size";
        type tcam-size-type;
      }
      leaf l3qos {
        tailf:info "IPV4 L3 QoS size";
        type tcam-size-type;
      }
      leaf qos {
        tailf:info "IPV4 Port QoS size";
        type tcam-size-type;
      }
      leaf racl {
        tailf:info "IPV4 RACL size";
        type tcam-size-type;
      }
      leaf span {
        tailf:info "SPAN size";
        type tcam-size-type;
      }
      leaf vpc-convergence {
        tailf:info "Vpc convergence size";
        type tcam-size-type;
      }
      leaf ipv6-l3qos {
        tailf:info "IPV6 L3 QoS size";
        type tcam-size-type;
      }
      leaf e-ipv6-qos {
        tailf:info "Egress IPV6 QoS size";
        type tcam-size-type;
      }
      leaf e-ipv6-racl {
        tailf:info "Egress IPV6 RACL size";
        type tcam-size-type;
      }
      leaf e-mac-qos {
        tailf:info "Egress MAC QoS size";
        type tcam-size-type;
      }
      leaf e-qos-lite {
        tailf:info "Egress IPV4 QoS (Lite) size";
        type tcam-size-type;
      }
      leaf fcoe-egress {
        tailf:info "Egress FCoE Counters size";
        type tcam-size-type;
      }
      leaf fcoe-ingress {
        tailf:info "Ingress FCoE Counters size";
        type tcam-size-type;
      }
      leaf fex-ifacl {
        tailf:info "FEX IPV4 PACL size";
        type tcam-size-type;
      }
      leaf fex-ipv6-ifacl {
        tailf:info "FEX IPV6 PACL size";
        type tcam-size-type;
      }
      leaf fex-ipv6-qos {
        tailf:info "FEX IPV6 Port QoS size";
        type tcam-size-type;
      }
      leaf fex-mac-ifacl {
        tailf:info "FEX MAC PACL size";
        type tcam-size-type;
      }
      leaf fex-mac-qos {
        tailf:info "FEX MAC Port QoS size";
        type tcam-size-type;
      }
      leaf fex-qos {
        tailf:info "FEX IPV4 Port QoS size";
        type tcam-size-type;
      }
      leaf fex-qos-lite {
        tailf:info "FEX IPV4 Port QoS (Lite) size";
        type tcam-size-type;
      }
      leaf flow {
        tailf:info "Ingress Flow Counters size";
        type tcam-size-type;
      }
      leaf ifacl {
        tailf:info "IPV4 PACL size";
        type tcam-size-type;
      }
      leaf ipsg {
        tailf:info "IPSG SMAC-IP bind table size";
        tailf:cli-diff-delete-before "../racl" {
          tailf:cli-when-target-delete;
        }
        type tcam-size-type;
      }
      leaf ipv6-ifacl {
        tailf:info "IPV6 PACL size";
        type tcam-size-type;
      }
      leaf ipv6-qos {
        tailf:info "IPV6 Port QoS size";
        type tcam-size-type;
      }
      leaf ipv6-vacl {
        tailf:info "IPV6 VACL size";
        type tcam-size-type;
      }
      leaf ipv6-vqos {
        tailf:info "IPV6 VLAN QoS size";
        type tcam-size-type;
      }
      leaf l3qos-lite {
        tailf:info "IPV4 L3 QoS (Lite) size";
        type tcam-size-type;
      }
      leaf mac-ifacl {
        tailf:info "MAC PACL size";
        type tcam-size-type;
      }
      leaf mac-l3qos {
        tailf:info "MAC L3 QoS size";
        type tcam-size-type;
      }
      leaf mac-qos {
        tailf:info "MAC Port QoS size";
        type tcam-size-type;
      }
      leaf mac-vacl {
        tailf:info "MAC VACL size";
        type tcam-size-type;
      }
      leaf mac-vqos {
        tailf:info "MAC VLAN QoS size";
        type tcam-size-type;
      }
      leaf mcast-performance {
        tailf:info "MCAST performance TCAM region size";
        type tcam-size-type;
      }
      leaf mcast_bidir {
        tailf:info "MCAST bidir TCAM region size";
        type tcam-size-type;
      }
      leaf mpls {
        tailf:info "Mpls TCAM region size";
        type tcam-size-type;
      }
      leaf nat {
        tailf:info "NAT TCAM size";
        type tcam-size-type;
      }
      leaf ns-ipv6-l3qos {
        tailf:info "NS IPV4 L3 QoS size";
        type tcam-size-type;
      }
      leaf ns-ipv6-qos {
        tailf:info "NS IPV6 Port QoS size";
        type tcam-size-type;
      }
      leaf ns-ipv6-vqos {
        tailf:info "NS IPV6 VLAN QoS size";
        type tcam-size-type;
      }
      leaf ns-l3qos {
        tailf:info "NS IPV4 L3 QoS size";
        type tcam-size-type;
      }
      leaf ns-mac-l3qos {
        tailf:info "NS MAC L3 QoS size";
        type tcam-size-type;
      }
      leaf ns-mac-qos {
        tailf:info "NS MAC Port QoS size";
        type tcam-size-type;
      }
      leaf ns-mac-vqos {
        tailf:info "NS MAC VLAN QoS size";
        type tcam-size-type;
      }
      leaf ns-qos {
        tailf:info "NS IPV4 Port QoS size";
        type tcam-size-type;
      }
      leaf ns-vqos {
        tailf:info "NS IPV4 VLAN QoS size";
        type tcam-size-type;
      }
      leaf openflow {
        tailf:info "OPENFLOW region size";
        type tcam-size-type;
      }
      leaf openflow-ipv6 {
        tailf:info "OPENFLOW IPV6 region size";
        type tcam-size-type;
      }
      leaf qos-lite {
        tailf:info "IPV4 Port QoS (Lite) size";
        type tcam-size-type;
      }
      leaf redirect {
        tailf:info "Redirect size";
        type tcam-size-type;
      }
      leaf redirect_v4 {
        tailf:info "Redirect v4 size";
        type tcam-size-type;
      }
      leaf redirect_v6 {
        tailf:info "Redirect v6 size";
        type tcam-size-type;
      }
      leaf redirect-tunnel {
        tailf:info "Redirect Tunnel size";
        type tcam-size-type;
      }
      leaf rp-ipv6-qos {
        tailf:info "Ranger Plus IPV6 QoS size";
        type tcam-size-type;
      }
      leaf rp-mac-qos {
        tailf:info "Ranger Plus MAC QoS size";
        type tcam-size-type;
      }
      leaf rp-qos {
        tailf:info "Ranger Plus IPV4 QoS size";
        type tcam-size-type;
      }
      leaf rp-qos-lite {
        tailf:info "Ranger Plus IPV4 QoS (Lite) size";
        type tcam-size-type;
      }
      leaf sflow {
        tailf:info "SFlow ACL size";
        type tcam-size-type;
      }
      leaf span-sflow {
        tailf:info "SPAN+sFlow ACL size";
        type tcam-size-type;
      }
      leaf svi {
        tailf:info "Ingress SVI Counters size";
        type tcam-size-type;
      }
      leaf vacl {
        tailf:info "IPV4 VACL size";
        type tcam-size-type;
      }
      leaf e-vacl {
        tailf:info "Configure tcam for e-vacl region";
        type tcam-size-type;
      }
      leaf vqos {
        tailf:info "IPV4 VLAN QoS size";
        type tcam-size-type;
      }
      leaf vqos-lite {
        tailf:info "IPV4 VLAN QoS (Lite) size";
        type tcam-size-type;
      }
      leaf ing-fstat {
        tailf:info "Ingress FSTAT";
        type tcam-size-type;
      }
      leaf ing-ifacl {
        tailf:info "Ingress IPv4, IPv6, or MAC port ACL TCAM region size";
        type tcam-size-type;
      }
      leaf ing-l2-qos {
        tailf:info "Ingress Layer 2 QoS TCAM region size";
        type tcam-size-type;
      }
      leaf ing-l2-span-filter {
        tailf:info "Ingress Layer 2 SPAN filter TCAM region size";
        type tcam-size-type;
      }
      leaf ing-l3-span-filter {
        tailf:info "Ingress Layer 3 and VLAN SPAN filter TCAM region size";
        type tcam-size-type;
      }
      leaf ing-l3-vlan-qos {
        tailf:info "Ingress Layer 3, VLAN, and SVI QoS TCAM region size";
        type tcam-size-type;
      }
      leaf ing-nbm {
        tailf:info "Ingress NBM";
        type tcam-size-type;
      }
      leaf ing-racl {
        tailf:info "IPv4 or IPv6 ingress router ACL (RACL) TCAM region size";
        type tcam-size-type;
      }
      leaf ing-rbacl {
        tailf:info "Ingress RBACL";
        type tcam-size-type;
      }
      leaf ing-flow-redirect {
        tailf:info "Ingress Flow Redirect";
        type tcam-size-type;
      }
      leaf ing-redirect {
        tailf:info "Redirect TCAM region size for DHCPv4 relay, DHCPv4 snooping, and DHCPv4 client";
        type tcam-size-type;
      }
      leaf ing-sup {
        tailf:info "Ingress supervisor TCAM region size";
        type tcam-size-type;
      }
      leaf ing-mvpn {
        type tcam-size-type;
      }
      leaf egr-l2-qos {
        tailf:info "Egress L2 QOS";
        type tcam-size-type;
      }
      leaf egr-l3-vlan-qos {
        tailf:info "Egress L3/VLAN QOS";
        type tcam-size-type;
      }
      leaf egr-racl {
        tailf:info "Egress IPv4 or IPv6 router ACL (RACL) TCAM region size";
        type tcam-size-type;
      }
      leaf egr-sup {
        tailf:info "Egress supervisor TCAM region size";
        type tcam-size-type;
      }
      leaf ing-netflow {
        tailf:info "Ingress Netflow/Analytics region";
        type tcam-size-type;
      }
    }
  }


  // =========================================================================
  //                        CUSTOM EXTENSIONS
  // =========================================================================

  extension redeploy-data {



    argument value;
  }

  extension data-category {
    argument value;

  }

  extension trim-default-on-delete {



  }

  extension quoted-string {



  }

  extension redeploy-pbr-stats {



  }

  extension macro-expand {
    argument value;



  }

  extension diff-list-delete-before-set {



  }

  extension verify-network-address {



  }

  extension delete-with {
    argument value; // default | none | <custom command line>



  }

  extension prune-leaf-list-duplicates {



  }

  extension flowcontrol-delete-with-toggle {



  }

  extension explicit-delete-when-empty {



  }

  extension trim-empty-create {



  }

  extension delete-vlan-mappings-on-delete {



  }

  extension must-be-less-than {
    argument value; // other leaf



  }

  extension show-on-create-only {



  }

  extension conditionally-inject-frequency {



  }

  extension maintenance-mode-cleanup {



  }

  extension device-transformed-value {



  }

  extension device-transformed-dependency {

  }

  extension explicit-ordered-by-user {



  }

  extension trim-default-in-show {



  }

  extension trim-default-in-diff {



  }

  extension split-interface-name {



  }

  extension split-compact-line {



  }

  extension delete-rsa-key {



  }

  extension dequote-input {



  }

  extension escape-questionmark {



  }

  extension no-to-disable {



  }

  extension explicit-delete-additive {



  }

  extension handle-allowed-vsan {



  }

  extension dayzero-config {



  }

  extension inject-vsan-in-db {



  }

  extension filter-non-config {



  }

  extension trim-default-key {



  }

  extension fix-per-module-lb {



  }

  extension reset-terminal-length {



  }

  extension toggle-hw-module-obfl {



  }

  extension handle-sr-mpls-no-mode {



  }

  extension escape-backslash {



  }

  extension edit-not-supported {



  }

  extension handle-no-list {



  }

  extension show-no-disable {



  }

  extension tri-state-boolean {



  }

  extension handle-allowed-vlan {



  }

  extension fix-send-community {



  }

  extension expand-bridge-domain {



  }

  extension expand-bd-member-vni {



  }

  extension scheduler-job-commands {



  }

  extension dot1q-vni-mappings {



  }

  extension iface-encap-profile-dot1q {



  }

  extension iface-breakout-port-range {



  }

  extension enum-alias {



  }

  extension inject-before {
    argument value;



  }

  extension inject-all-allowed-vlans {



  }

  extension dequote-output {



  }

  extension obu-redeploy-on-edit {



  }

  extension redeploy-dependency {
    argument value;

  }

  extension snmp-server-all-traps {



  }

  extension prefix-key-leaf-list {



  }

  extension case-insensitive-type {



  }

  extension vrf-member-chg-retain-l3 {



  }

  extension comma-separated-list {



  }

  extension reactivate-zoneset {



  }

  extension commit-zone {



  }

  extension auto-reset-shutdown {



  }

  extension before-exit-configure {



  }

  extension filter-in-show {



  }


  // =========================================================================
  //                        MODEL
  // =========================================================================

  /// ========================================================================
  /// tailfned
  /// ========================================================================
  /// TAILF NED device info used for device specific support.

  container tailfned {
    // NOTE: don't touch these, for internal use in NED (see ned-settings)
    leaf iface-vlan-ipv6-secondary {
      type empty;
    }

    leaf port-channel-load-balance-ethernet {
      type empty;
    }

    leaf default-lacp-suspend-individual {
      type boolean;
    }

    leaf dayzero-included {
      type empty;
    }

    leaf dayzero-permit-write {
      type empty;
    }

    leaf support-per-module-obfl {
      type empty;
    }

    leaf lldp-tlv-select-support {
      type empty;
    }

    leaf snmp-server-enable-all-traps {
      type empty;
    }
  }


  /// ========================================================================
  /// EXEC (exec commands executed in config mode)
  /// ========================================================================

  container EXEC {
    tailf:cli-drop-node-name;

    // execute (run config exec ommands, e,g,; 'crypto key generate' or
    // 'default interface Ethernet 1/1')
    tailf:action "exec" {
      tailf:info "Execute config exec-commands, e.g. 'crypto key generate' or '"
        + "default interface Ethernet 1/1'";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf-list args {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "ACTION:;;exec <command> <argument(s)> [options]";
          }
        }
      }
      output {
        leaf result {
          type string;
        }
      }
    }

  }



  /// ========================================================================
  /// version
  /// ========================================================================

  leaf version {
    tailf:info "Version";
    tailf:cli-multi-value;
    type string {
      tailf:info "WORD;;Version number";
    }
  }


  /// ========================================================================
  /// hostname
  /// ========================================================================

  // NOTE: This should be a choice, but we can't have choice on top-level
  //  choice hostname-or-switchname {
  leaf hostname {
    tailf:info "Set system's network name";
    type string {
      tailf:info "This system's network name";
    }
  }

  leaf switchname {
    tailf:info "Configure system's host name";
    type string {
      tailf:info "WORD;;Enter switchname (Max Size 32)";
    }
  }
  //  }

  /// ========================================================================
  /// feature
  /// ========================================================================

  container feature {
    tailf:info "Command to enable/disable features";

    leaf bash-shell {
      tailf:info "Enable/Disable bash-shell";
      type empty;
    }
    leaf bgp {
      tailf:info "Enable/Disable Border Gateway Protocol (BGP)";
      type empty;
    }
    leaf bfd {
      tailf:info "Bfd";
      type empty;
    }
    leaf cable-management {
      tailf:info "Enable/Disable Cable Management Manager (CMM)";
      type empty;
    }
    leaf dot1x {
      tailf:info "Enable/Disable dot1x";
      type empty;
    }
    leaf cts {
      tailf:info "Enable/Disable CTS";
      tailf:cli-diff-dependency "../dot1x";
      type empty;
    }
    leaf eigrp {
      tailf:info "Enable/Disable Enhanced Interior Gateway Routing Protocol ("
        +"EIGRP)";
      type empty;
    }
    leaf ethernet-link-oam {
      tailf:info "Enable/Disable Ethernet Link OAM";
      type empty;
    }
    leaf evmed {
      tailf:info "Enable/Disable Generic event detectors";
      type empty;
    }
    // feature fabric
    container fabric {
      tailf:info "Enable/Disable fabric network services";
      // feature fabric access
      leaf access {
        tailf:info "Enable/Disable Single Point of Access (XMPP Client) for the"
          +" fabric network";
        type empty;
      }
      // feature fabric forwarding
      leaf forwarding {
        tailf:info "Enable/Disable Fabric Forwarding Protocol: Host Mobility Ma"
          +"nager (HMM)";
        type empty;
      }
      // feature fabric multicast
      leaf multicast {
        tailf:info "Enable/Disable NGMVPN features";
        type empty;
      }
    }
    leaf fabricpath-vpn {
      tailf:info "Enable/Disable fabricpath-vpn services";
      tailf:cli-diff-set-after "/nx:feature-set/fabricpath";
      type empty;
    }
    leaf fabric-binding {
      tailf:info "Enable/Disable Fabric Binding";
      type empty;
    }
    leaf fcoe {
      tailf:info "Enable/Disable FCoE/FC feature";
      type empty;
    }
    leaf fcoe-npv {
      tailf:info "Enable/Disable FCoE NPV feature";
      type empty;
    }
    leaf frequency-synchronization {
      tailf:info "Enable/Disable fsync";
      type empty;
    }
    leaf fex {
      tailf:info "Enable/Disable FEX";
      type empty;
    }
    leaf fport-channel-trunk {
      tailf:info "Enable/Disable Trunking F Ports and channels";
      type empty;
    }
    leaf grpc {
      tailf:info "Enable/Disable grpc Services";
      type empty;
    }
    leaf glbp {
      tailf:info "Enable/Disable Gateway Load Balancing Protocol (GLBP)";
      type empty;
    }
    leaf flexlink {
      tailf:info "Enable/Disable Flexlink";
      type empty;
    }
    leaf hardware-telemetry {
      tailf:info "Enable/Disable Hardware Telemetry";
      type empty;
    }
    leaf hsrp {
      tailf:info "Enable/Disable Hot Standby Router Protocol (HSRP)";
      type empty;
    }
    leaf icam {
      tailf:info "Enable/Disable icam";
      type empty;
    }
    leaf itd {
      tailf:info "Enable/Disable ITD";
      type empty;
    }
    leaf macsec {
      tailf:info "Enable/Disable CTS";
      type empty;
    }
    leaf msdp {
      tailf:info "Enable/Disable Multicast Source Discovery Protocol (MSDP)";
      type empty;
    }
    container mpls {
      tailf:cli-diff-set-after "/nx:feature-set/mpls";
      leaf l2vpn {
        tailf:info "Enable/Disable Layer 2 Virtual Private Networks";
        type empty;
      }
      leaf l3vpn {
        type empty;
      }

      leaf ldp {
        tailf:info "Enable/Disable Label Distribution Protocol";
        type empty;
      }
      leaf segment-routing {
        tailf:info "Enable Segment-routing";
        type empty;
      }
      leaf evpn {
        tailf:info "Enable MPLS EVPN";
        type empty;
      }
      leaf oam {
        tailf:info "Enable MPLS OAM";
        type empty;
      }
    }
    // feature nat
    leaf nat {
      tailf:info "Enable/Disable NAT";
      type empty;
    }
    leaf ngmvpn {
      tailf:info "Enable/Disable Next-Generation Multicast VPN (ngMVPN)";
      type empty;
    }
    leaf ngoam {
      tailf:info "Enable/Disable ngoam";
      type empty;
    }
    leaf npiv {
      tailf:info "Nx port Id Virtualization (NPIV) feature enable";
      type empty;
    }
    leaf npv {
      tailf:info "Enable/Disable FC N_port Virtualizer";
      type empty;
    }
    leaf ntp {
      tailf:info "Enable/Disable NTP";
      type empty;
    }
    // feature nv
    container nv {
      tailf:info "Enable/Disable NV Overlay";
      // feature nv overlay
      leaf overlay {
        tailf:info "Enable/Disable NV Overlay";
        tailf:cli-diff-delete-before "../../vn-segment-vlan-based" {
          tailf:cli-when-target-delete;
        }
        type empty;
      }
    }
    leaf nxapi {
      tailf:info "Enable/Disable nxapi";
      type empty;
    }
    leaf network-segmentation-manager {
      tailf:info "Enable/Disable network segmentation manager";
      type empty;
    }
    leaf lisp {
      tailf:info "Enable/Disable Locator/ID Separation Protocol (LISP)";
      type empty;
    }
    leaf ldap {
      tailf:info "Enable/Disable ldap";
      type empty;
    }
    leaf lldp {
      tailf:info "Enable/Disable LLDP";
      type empty;
    }
    leaf pbr {
      tailf:info "Enable/Disable Policy Based Routing(PBR)";
      type empty;
    }
    leaf ospf {
      tailf:info "Enable/Disable Open Shortest Path First Protocol (OSPF)";
      type empty;
    }
    leaf ospfv3 {
      tailf:info "Enable/Disable Open Shortest Path First Version 3 Protocol ("
        +"OSPFv3)";
      type empty;
    }
    leaf otv {
      tailf:info "Enable/Disable Overlay Transport Virtualization (OTV)";
      type empty;
    }
    container password {
      tailf:info "Credential(s) for the user(s)/device(s)";
      container encryption {
        tailf:info "Strong encryption for credential(s)";
        leaf aes {
          tailf:info "Encrypt using AES encryption standard";
          type empty;
        }
      }
    }
    leaf pim {
      tailf:info "Enable/Disable Protocol Independent Multicast (PIM)";
      type empty;
    }
    leaf pim6 {
      tailf:info "Enable/Disable Protocol Independent Multicast (PIM) for IPv6";
      type empty;
    }
    leaf poe {
      tailf:info "Enable/Disable PoE";
      type empty;
    }
    leaf pong {
      tailf:info "Enable/Disable Pong";
      type empty;
    }
    leaf port-security {
      tailf:info "Enable/Disable port-security";
      type empty;
    }
    leaf privilege {
      tailf:info "Enable/Disable IOS type privilege level support";
      type empty;
    }
    leaf ptp {
      tailf:info "Enable/Disable PTP";
      type empty;
    }
    leaf restconf {
      tailf:info "Enable/Disable restconf Services";
      type empty;
    }
    leaf rip {
      tailf:info "Enable/Disable Routing Information Protocol (RIP)";
      type empty;
    }
    leaf segmentation {
      tailf:info "Enable/Disable Segmentation/BD feature";
      type empty;
    }
    leaf scheduler {
      tailf:info "Enable/Disable scheduler";
      type empty;
    }
    leaf scp-server {
      tailf:info "Enable/Disable SCP server";
      type empty;
    }
    leaf sftp-server {
      tailf:info "Enable/Disable SFTP server";
      type empty;
    }
    leaf sflow {
      tailf:info "Enable/Disable sFlow agent";
      type empty;
    }
    leaf signature-verification {
      tailf:info "Enable image signature verification";
      type empty;
    }
    container sla {
      tailf:info "Enable/Disable SLA";
      leaf responder {
        tailf:info "Enable/Disable responder part of SLA";
        type empty;
      }
      leaf sender {
        tailf:info "Enable/Disable sender part of SLA";
        type empty;
      }
    }
    leaf udld {
      tailf:info "Enable/Disable UDLD";
      type empty;
    }
    leaf vni {
      tailf:info "Enable/Disable Virtual Network Segment (VNI)";
      type empty;
    }
    leaf vn-segment-vlan-based {
      tailf:info "Enable/Disable VLAN based VN segment";
      tailf:cli-diff-delete-before "../mpls/segment-routing";
      type empty;
    }
    leaf vpc {
      tailf:info "Enable/Disable VPC (Virtual Port Channel)";
      type empty;
    }
    leaf vrrp {
      tailf:info "Enable/Disable Virtual Router Redundancy Protocol (VRRP)";
      type empty;
    }
    leaf vrrpv3 {
      tailf:info "Enable/Disable Virtual Router Redundancy Protocol (VRRP) version 3";
      type empty;
    }
    leaf vtp {
      tailf:info "Enable/Disable Vlan Trunking Protocol (VTP)";
      type empty;
    }
    leaf dhcp {
      tailf:info "Enable/Disable DHCP Snooping";
      type empty;
    }
    leaf http-server {
      type empty;
      tailf:info "Enable/Disable http-server";
    }
    leaf imp {
      tailf:info "Enable/Disable IMP";
      type empty;
    }
    leaf interface-vlan {
      tailf:info "Enable/Disable interface vlan";
      type empty;
    }
    leaf isis {
      tailf:info "Enable/Disable IS-IS Unicast Routing Protocol (IS-IS)";
      type empty;
    }
    leaf lacp {
      tailf:info "Enable/Disable LACP";
      type empty;
    }
    leaf netconf {
      tailf:info "Enable/Disable netconf Services";
      type empty;
    }
    leaf netflow {
      tailf:info "Enable/Disable NetFlow";
      type empty;
    }
    leaf port-profile-roles {
      tailf:info "Enable/Disable Port-profile Roles Feature";
      type empty;
    }
    leaf private-vlan {
      tailf:info "Enable/Disable private-vlan";
      type empty;
    }
    leaf ssh {
      tailf:info "Enable/Disable ssh";
      type empty;
    }
    leaf tacacs-plus {
      tailf:alt-name "tacacs+";
      type empty;
      tailf:info "Enable/Disable tacacs+";
    }
    leaf telemetry {
      tailf:info "Enable/Disable Telemetry";
      type empty;
    }
    leaf telnet {
      type empty;
      tailf:cli-show-no;
      tailf:info "Enable/Disable telnet";
    }
    // feature tunnel
    leaf tunnel {
      tailf:info "Enable/Disable Tunnel Manager";
      type empty;
    }
    leaf vpd {
      type empty;
      tailf:info "Enable/Disable VPC";
    }
  }


  /// ========================================================================
  /// password
  /// ========================================================================

  container password {
    tailf:info "Password for the user";
    leaf strength-check {
      tailf:info "Strength check of password";
      tailf:cli-boolean-no;
      type boolean;
      default "true";
    }
    leaf secure-mode {
      tailf:info "Enable secure mode for changing password";
      tailf:cli-boolean-no;
      type boolean;
      default "true";
    }
  }


  /// ========================================================================
  /// fabric-mode
  /// ========================================================================

  leaf fabric-mode {
    tailf:info "Set switch fabric-mode";
    tailf:cli-case-insensitive;
    type enumeration {
      enum 10g {
        tailf:info "Sets the fabric mode to 10G";
      }
      enum 40g {
        tailf:info "Sets the fabric mode to 40G";
      }
    }
  }


  /// ========================================================================
  /// poweroff
  /// ========================================================================

  container poweroff {
    tailf:info "Power off a module in the switch";
    leaf module {
      tailf:info "Enter a module number";
      type uint8;
    }
  }


  /// ========================================================================
  /// power
  /// ========================================================================

  container power {
    tailf:info "Configure power supply";
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands {
      tailf:cli-reset-siblings;
    }
    leaf redundancy-mode {
      tailf:info "Configure power supply redundancy mode";
      type enumeration {
        enum combined {
          tailf:info "Configure power supply redundancy mode as combined";
        }
        enum insrc-redundant {
          tailf:info "Configure power supply redundancy mode as grid/AC input source redundant";
        }
        enum ps-redundant {
          tailf:info "Configure power supply redundancy mode as PS redundant";
        }
        enum redundant {
          tailf:info "Configure power supply redundancy mode as InSrc and PS redundant";
        }
      }
    }
    leaf force {
      tailf:info "Force combined mode without prompting";
      tailf:cli-no-name-on-delete;
      type empty;
    }
  }


  /// ========================================================================
  /// nv
  /// ========================================================================
  container nv {
    tailf:info "Command to enable/disable features";
    // nv overlay
    container overlay {
      tailf:info "Command to enable/disable features";
      // nv overlay evpn
      leaf evpn {
        tailf:info "Enable/Disable Ethernet VPN (EVPN)";
        tailf:cli-diff-delete-before "/nx:feature/mpls/segment-routing";
        tailf:cli-diff-delete-before "/nx:feature/nv/overlay";
        type empty;
      }
    }
  }

  /// ========================================================================
  /// vni
  /// ========================================================================

  // vni * <CR>
  container vni {
    tailf:info "Virtual Network Identifier";
    leaf-list vni {
      tailf:info "Virtual Network Identifier";
      tailf:cli-drop-node-name;
      tailf:cli-range-list-syntax;
      tailf:cli-diff-dependency "../../feature/vni";
      nx:prune-leaf-list-duplicates;
      when "../../feature/vni" {
        tailf:dependency "../../feature/vni";
      }
      type uint32 {
        tailf:info "<4096-16777215>;;Vni range, Example: "
          +"4096,4099-5013,5019,6011-6099";
        range "4096..16777215";
      }
    }
  }

  /// ========================================================================
  /// tacacs-server
  /// ========================================================================
  container tacacs-server {
    tailf:info "Configure TACACS+ server related parameters";
    tailf:cli-compact-syntax;
    tailf:cli-diff-dependency "../feature/tacacs-plus";
    // FIXME: netsim doesn't handle rollbacks with this
    // when "../feature/tacacs-plus" {
    //   tailf:dependency "../feature/tacacs-plus";
    // }
    // tacacs-server deadtime
    leaf deadtime {
      tailf:info "Duration for which non-reachable server is skipped";
      tailf:cli-full-command;
      type uint16 {
        range "0..1440";
      }
    }

    // tacacs-server directed-request
    leaf directed-request {
      tailf:info "Enable direct authentication requests to server";
      tailf:cli-full-command;
      type empty;
    }

    // tacacs-server host
    list host {
      tailf:info "TACACS+ server's DNS name or its IP address";
      tailf:cli-compact-syntax;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      ordered-by user;
      nx:explicit-delete-when-empty;
      nx:obu-redeploy-on-edit;
      nx:redeploy-dependency "../../aaa/group/server/tacacs-plus/server[id=%s]";
      key id;
      leaf id {
        tailf:info "IPV4/IPV6 address or DNS name";
        type union {
          type inet:ipv4-address;
          type inet:ipv6-address;
          type string;
        }
      }

      // tacacs-server host secret
      container secret {
        tailf:cli-drop-node-name;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;

        // tacacs-server host secret key
        leaf key {
          tailf:info "TACACS+ shared secret";
          tailf:cli-incomplete-command;
          nx:device-transformed-dependency;
          type enumeration {
            enum "0" {
              tailf:info "TACACS+ shared secret(clear text)";
            }
            enum "6" {
              tailf:info "TACACS+ shared secret(type-6 encrypted)";
            }
            enum "7" {
              tailf:info "TACACS+ shared secret(encrypted)";
            }
          }
        }

        // tacacs-server host secret shared-secret
        leaf shared-secret {
          tailf:cli-drop-node-name;
          nx:device-transformed-value;
          type string {
            tailf:info "TACACS+ shared secret";
          }
        }
      }

      // tacacs-server host port
      leaf port {
        tailf:info "TACACS+ server port";
        type uint16;
      }

      // tacacs-server host test
      container test {
        tailf:info "Parameters to send test packets";
        tailf:cli-flatten-container;
        tailf:cli-optional-in-sequence;
        when "not(../port)" {
          tailf:dependency "../port";
        }

        // tacacs-server host test idle-time
        leaf idle-time {
          tailf:info "Time interval for monitoring the server";
          tailf:cli-full-command;
          type uint16 {
            range "1..1440";
          }
        }

        // tacacs-server host test password
        leaf password {
          tailf:info "User password in test packets";
          tailf:cli-full-command;
          type string {
            length "1..32";
          }
        }

        // tacacs-server host test username
        leaf username {
          tailf:info "User name in test packets";
          type string {
            length "1..32";
          }
        }
      }

      // tacacs-server host timeout
      leaf timeout {
        tailf:info "TACACS+ server timeout period in seconds";
        tailf:cli-full-command;
        type uint8 {
          range "1..60";
        }
      }
    }

    // tacacs-server secret
    container secret {
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-drop-node-name;

      // tacacs-server secret key
      leaf key {
        tailf:info "TACACS+ shared secret";
        tailf:cli-incomplete-command;
        nx:device-transformed-dependency;
        type enumeration {
          enum "0" {
            tailf:info "TACACS+ shared secret(clear text)";
          }
          enum "6" {
            tailf:info "TACACS+ shared secret(type-6 encrypted)";
          }
          enum "7" {
            tailf:info "TACACS+ shared secret(encrypted)";
          }
        }
      }

      // tacacs-server secret shared-secret
      leaf shared-secret {
        tailf:cli-drop-node-name;
        nx:device-transformed-value;
        type string {
          tailf:info "TACACS+ shared secret";
        }
      }
    }

    // tacacs-server test
    container test {
      tailf:info "Parameters to send test packets";
      when "not(../secret/key)" {
        tailf:dependency "../secret/key";
      }

      // tacacs-server test idle-time
      leaf idle-time {
        tailf:info "Time interval for monitoring the server";
        tailf:cli-full-command;
        type uint16 {
          range "1..1440";
        }
      }

      // tacacs-server test password
      leaf password {
        tailf:info "User password in test packets";
        tailf:cli-full-command;
        type string {
          length "1..32";
        }
      }

      // tacacs-server test username
      leaf username {
        tailf:info "User name in test packets";
        type string {
          length "1..32";
        }
      }
    }

    // tacacs-server timeout
    leaf timeout {
      tailf:info "TACACS+ server timeout period in seconds";
      tailf:cli-full-command;
      default 5;
      type uint8 {
        range "1..60";
      }
    }
  }

  /// ========================================================================
  /// radius-server
  /// ========================================================================

  container radius-server {
    tailf:info "Configure RADIUS related parameters";

    leaf deadtime {
      tailf:info "Duration for which non-reachable server is skipped";
      type uint16 {
        tailf:info "<0-1440>;;Length of time, in minutes";
        range "0..1440";
      }
    }

    leaf directed-request {
      tailf:info "Enable direct authentication requests to server";
      type empty;
    }

    list host {
      tailf:info "RADIUS server's DNS name or its IP address";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      ordered-by user;
      nx:explicit-delete-when-empty {

      }
      nx:obu-redeploy-on-edit;
      nx:redeploy-dependency "../../aaa/group/server/radius/server[id=%s]";

      key id;
      leaf id {
        tailf:info "A:B::C:D|WORD;;IPV4/IPV6 address or DNS name";
        type union {
          type inet:ip-address {
            tailf:info "A.B.C.D;;IPV4 address";
          }
          type inet:ipv6-address {
            tailf:info "A:B::C:D;;IPV6 address";
          }
          type string {
            tailf:info "WORD;;DNS name";
          }
        }
      }
      container key {
        tailf:info "RADIUS shared secret";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          nx:device-transformed-dependency;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum "7" {
              tailf:info "Specifies a HIDDEN password will follow";
            }
            enum "6" {
              tailf:info "Specifies a type6 encrypted password will follow";
            }
          }
        }
        leaf password {
          tailf:cli-drop-node-name;
          nx:device-transformed-value;
          type string {
            tailf:info "WORD;;The HIDDEN user password string";
          }
        }
      }
      leaf pac {
        tailf:info "Secure Radius Enable";
        type empty;
      }
      leaf auth-port {
        tailf:info "RADIUS server's port for authentication";
        default "1812";
        type uint16 {
          tailf:info "<0-65535>;;Port number";
        }
      }
      leaf acct-port {
        tailf:info "RADIUS server's port for accounting";
        default "1813";
        type uint16 {
          tailf:info "<0-65535>;;Port number";
        }
      }
      leaf authentication {
        tailf:info "Use for authentication";
        type empty;
      }
      leaf accounting {
        tailf:info "Use for accounting";
        type empty;
      }
      leaf timeout {
        tailf:info "RADIUS server timeout period in seconds";
        type uint8 {
          tailf:info "<1-60>;;RADIUS server timeout period in seconds";
          range "1..60";
        }
      }
      leaf retransmit {
        tailf:info "RADIUS server retransmit count";
        type uint8 {
          tailf:info "<0-5>;;RADIUS server retransmit count";
          range "0..5";
        }
      }
    }
    container key {
      tailf:info "Global RADIUS server shared secret";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        nx:device-transformed-dependency;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "7" {
            tailf:info "Specifies a HIDDEN password will follow";
          }
          enum "6" {
            tailf:info "Specifies a type-6 encrypted password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-trim-default;
        nx:device-transformed-value;
        type string {
          tailf:info "WORD;;The HIDDEN user password string";
        }
      }
    }
    leaf retransmit {
      tailf:info "Global RADIUS server retransmit count";
      type uint8 {
        tailf:info "<0-5>;;Global RADIUS server retransmit count";
        range "0..5";
      }
    }
    //  test              Parameters to send test packets
    leaf timeout {
      tailf:info "Global RADIUS server timeout period in seconds";
      type uint8 {
        tailf:info "<1-60>;;RADIUS server timeout period in seconds";
        range "1..60";
      }
    }
  }


  /// ========================================================================
  /// ldap
  /// ========================================================================

  container ldap {
    tailf:info "Configure information about ldap";
    tailf:cli-diff-dependency "../feature/ldap";
    list search-map {
      tailf:info "Configure the search-map";
      key name;
      leaf name {
        tailf:info "WORD;;Search Map Name  (Max Size 128)";
        type string;
      }
      grouping attr-filter-grouping {
        leaf attribute-name {
          tailf:info "LDAP attribute-name";
          type string {
            tailf:info "WORD;;Search Map attribute-name  (Max Size 128)";
          }
        }
        leaf search-filter {
          tailf:info "LDAP search-filter";
          type string {
            tailf:info "WORD;;Search Map search-filter  (Max Size 128)";
          }
        }
        leaf base-DN {
          tailf:info "LDAP base-DN";
          type string {
            tailf:info "WORD;;Search Map base-DN Name  (Max Size 128)";
          }
        }
      }
      container CRLLookup {
        tailf:info "Set the CRLLookup";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses attr-filter-grouping;
      }
      container trustedCert {
        tailf:info "Set the trustedCert";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses attr-filter-grouping;
      }
      container user-certdn-match {
        tailf:info "Set the certificate matching";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses attr-filter-grouping;
      }
      container user-pubkey-match {
        tailf:info "Set the pubkey matching";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses attr-filter-grouping;
      }
      container user-switch-bind {
        tailf:info "Set the user-switch-bind";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses attr-filter-grouping;
      }
      container userprofile {
        tailf:info "Set the userprofile";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses attr-filter-grouping;
      }
    }
  }


  /// ========================================================================
  /// ldap-server
  /// ========================================================================

  container ldap-server {
    tailf:info "Configure LDAP related parameters";
    tailf:cli-diff-dependency "../feature/ldap";
    leaf deadtime {
      tailf:info "Global LDAP server deadtime period in seconds";
      type uint8 {
        tailf:info "<1-60>;;LDAP server deadtime period in minutes (default 0 mins -disabled)";
      }
    }
    leaf timeout {
      tailf:info "Global LDAP server timeout period in seconds";
      type uint8 {
        tailf:info "<1-60>;;LDAP server timeout period in seconds (default 5 sec)";
      }
    }
    list host {
      tailf:info "LDAP server's DNS name or IP address";
      key name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      ordered-by user;
      nx:obu-redeploy-on-edit;
      nx:redeploy-dependency "../../aaa/group/server/ldap/server[name=%s]";
      leaf name {
        type string {
          tailf:info "A.B.C.D|A:B::C:D|WORD;;IPV4/IPV6 address or DNS name";
        }
      }
      leaf enable-ssl {
        tailf:info "LDAP server enable ssl";
        type empty;
      }
      leaf referral-disable {
        tailf:info "LDAP server disable referrals";
        type empty;
      }
      container host-config {
        tailf:cli-drop-node-name;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf rootDN {
          tailf:info "LDAP server root DN";
          type string {
            tailf:info "WORD;;Root DN  (Max Size 128)";
          }
        }
        container password {
          tailf:info "LDAP server root password";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf encrypted {
            tailf:alt-name "7";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            nx:device-transformed-dependency;
            type empty;
          }
          leaf password {
            tailf:cli-drop-node-name;
            nx:device-transformed-value;
            type string {
              tailf:info "WORD  Password (clear text)  (Max Size 64)";
            }
          }
        }
        leaf port {
          tailf:info "LDAP server's port (default: global config)";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<1-65535>;;Port number";
          }
        }
        leaf timeout {
          tailf:info "LDAP server timeout period in seconds";
          type uint8 {
            tailf:info "<1-60>;;LDAP server timeout in seconds (default: global config)";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// aaa
  /// ========================================================================

  container aaa {
    tailf:info "Configure aaa functions";
    tailf:cli-diff-dependency "/nx:tacacs-server";

    grouping groups-and-fallback-grouping {
      leaf group {
        tailf:info "Specify server groups";
        tailf:cli-optional-in-sequence;
        tailf:cli-disallow-value "local|none";
        type string {
          tailf:info "WORD;;Server group name (Max Size 127)";
          length "1..127";
        }
      }

      leaf group2 {
        when "../group" {
          tailf:dependency "../group";
        }
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "local|none";
        type string {
          tailf:info "WORD;;Server group name (Max Size 127)";
          length "1..127";
        }
      }

      leaf group3 {
        when "../group2" {
          tailf:dependency "../group2";
        }
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "local|none";
        type string {
          tailf:info "WORD;;Server group name (Max Size 127)";
          length "1..127";
        }
      }

      leaf fallback {
        tailf:cli-drop-node-name;
        default "local";
        type enumeration {
          enum local {
            tailf:info "Use local RBACL based authorization";
          }
          enum none {
            tailf:info "No authorization";
          }
        }
      }
    }

    // aaa group
    container group {
      tailf:info "Configure aaa server group";

      // aaa group server
      container server {
        tailf:info "Configure aaa server group";

        // aaa group server radius
        list radius {
          tailf:info "RADIUS server group name";
          key id;
          leaf id {
            type string {
              length "1..127";
            }
          }
          // aaa group server radius WORD / deadtime <0-1440> <CR>
          leaf deadtime {
            tailf:info "Duration for which non-reachable server is skipped";
            type uint16 {
              tailf:info "<0-1440>;;Length of time, in minutes";
            }
          }

          // aaa group server radius WORD / server WORD <CR>
          list server {
            tailf:info "RADIUS server name or IP address";
            tailf:cli-suppress-mode;
            ordered-by user;
            tailf:cli-show-long-obu-diffs;
            key id;
            leaf id {
              tailf:non-strict-leafref {
                path "/nx:radius-server/host/id";
              }
              type union {
                type inet:ip-address {
                  tailf:info "A.B.C.D;;IPV4 address";
                }
                type inet:ipv6-address {
                  tailf:info "A:B::C:D;;IPV6 address";
                }
                type string {
                  tailf:info "WORD;;DNS name";
                }
              }
            }
          }
          // aaa group server radius WORD / source-interface
          container source-interface {
            tailf:info "Source interface to be used to reach radius server";
            tailf:cli-reset-container;
            // aaa group server radius WORD /
            //   source-interface Ethernet <1-253>/<1-256>.<1-511> <CR>
            leaf Ethernet {
              tailf:info "Ethernet IEEE 802.3z";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type string {
                tailf:info "<1-253>/<1-256>;;Slot/chassis number";
                pattern "\\d+/\\d+(\\.\\d+)?";
              }
            }
            // aaa group server radius WORD /
            //   source-interface loopback <0-1023>
            leaf loopback {
              tailf:info "Loopback interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type uint16 {
                tailf:info "<0-1023>;;Virtual interface number";
                range "0..1023";
              }
            }
            // aaa group server radius WORD / source-interface mgmt 0 <CR>
            leaf mgmt {
              tailf:info "Management interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type uint16 {
                tailf:info "<0-0>;;Management interface number";
                range "0..1023";
              }
            }
            // aaa group server radius WORD / source-interface null 0 <CR>
            leaf Null {
              tailf:info "Null interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type uint16 {
                tailf:info "<0-0>;;Null interface number";
                range "0..1023";
              }
            }
            // aaa group server radius WORD /
            //   source-interface port-channel <1-4096> <CR>
            leaf port-channel {
              tailf:info "Port Channel interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type uint16 {
                tailf:info "<1-4096>;;Port Channel number";
                range "1..4096";
              }
            }
            // aaa group server radius WORD / source-interface sup-eth 0 <CR>
            leaf sup-eth {
              tailf:info "Ethernet Inband interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type uint16 {
                tailf:info "<0-0>;;Ethernet Inband interface number";
                range "0..1023";
              }
            }
            // aaa group server radius WORD /
            //   source-interface vlan <1-4094> <CR>
            leaf vlan {
              tailf:info "Vlan interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type uint16 {
                tailf:info "<1-4094>;;Vlan interface number";
                range "0..4094";
              }
            }
          }
          // aaa group server radius WORD / use-vrf
          leaf use-vrf {
            tailf:info "Vrf to be used to contact servers in this group";
            // aaa group server radius WORD /
            //   use-vrf WORD|default|management
            tailf:cli-trim-default;
            default "default";
            type vrf-member-type;
          }
        }

        // aaa group server tacacs-plus
        list tacacs-plus {
          tailf:info "TACACS+ server group name";
          tailf:cli-full-command;
          tailf:alt-name "tacacs+";
          tailf:cli-diff-dependency "../../../../feature/tacacs-plus";
          when "../../../../feature/tacacs-plus" {
            tailf:dependency "../../../../feature/tacacs-plus";
          }
          key id;
          leaf id {
            type string {
              length "1..127";
            }
          }

          // aaa group server tacacs-plus server
          list server {
            tailf:info "TACACS+ server name or IP address";
            tailf:cli-suppress-mode;
            ordered-by user;
            tailf:cli-show-long-obu-diffs;
            key id;
            leaf id {
              type leafref {
                path "/nx:tacacs-server/host/id";
              }
            }
          }

          // aaa group server tacacs-plus source-interface
          leaf source-interface {
            tailf:info "Source interface to be used to reach tacacs server";
            tailf:cli-full-command;
            nx:case-insensitive-type;
            // Should be a leafref to existing interface
            type string;
          }

          // aaa group server tacacs-plus use-vrf
          leaf use-vrf {
            tailf:info "Vrf to be used to contact servers in this group";
            tailf:cli-full-command;
            tailf:cli-trim-default;
            default "default";
            type vrf-member-type;
          }

          leaf deadtime {
            tailf:info "Duration for which non-reachable server is skipped";
            default 0;
            type uint16 {
              tailf:info "<0-1440>;;Length of time, in minutes";
            }
          }
        }

        list ldap {
          tailf:info "LDAP server group name";
          tailf:cli-diff-dependency "/nx:feature/ldap";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;LDAP server group name  (Max Size 64)";
            }
          }

          container authentication {
            tailf:info "Set the authentication method";
            container bind-first {
              tailf:info "Set the authentication method to bind-first";
              presence true;
              leaf append-with-basedn {
                tailf:info "Change the default value (cn=$userid)";
                type string {
                  tailf:info "WORD;;Append with dn value (Max Size 63)";
                }
              }
            }
            container compare {
              tailf:info "Change the default attribute";
              presence true;
              leaf password-attribute {
                tailf:info "Change the default password attribute (userPassword)";
                type string {
                  tailf:info "WORD;;Password attribute (Max Size 63)";
                }
              }
            }
          }

          container enable {
            tailf:info "Enable";
            leaf Cert-DN-match {
              tailf:info "Enable/Disable Cert-DN matching";
              type empty;
            }
            leaf user-server-group {
              tailf:info "Enable/Disable group validation";
              type empty;
            }
          }

          leaf ldap-search-map {
            tailf:info "Set one of the configured search-map as active";
            tailf:non-strict-leafref {
              path "/nx:ldap/search-map/name";
            }
            type string {
              tailf:info "WORD;;Name of the search-map  (Max Size 128)";
            }
          }

          list server {
            tailf:info "TACACS+ server name or IP address";
            tailf:cli-suppress-mode;
            ordered-by user;
            tailf:cli-show-long-obu-diffs;
            key name;
            leaf name {
              type leafref {
                path "/nx:ldap-server/host/name";
              }
            }
          }

          leaf deadtime {
            tailf:info "Duration for which non-reachable server is skipped";
            default 0;
            type uint16 {
              tailf:info "<0-1440>;;Length of time, in minutes";
            }
          }
        }
      }
    }

    // aaa server
    container server {
      tailf:info "Local AAA server";
      container radius {
        tailf:info "Profile for local radius server";
        container dynamic-author {
          tailf:info "Local server profile for RFC 5176 support";
          presence "true";
          tailf:cli-add-mode;
          list client {
            tailf:info "Specify a RADIUS client";
            tailf:cli-suppress-mode;
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            nx:explicit-delete-when-empty;
            key addr;
            leaf addr {
              type union {
                type inet:ipv4-address;
                type inet:ipv6-address;
                type string;
              }
            }

            leaf vrf {
              tailf:non-strict-leafref {
                path "/nx:vrf/context/id";
              }
              type vrf-member-type;
            }

            container server-key {
              tailf:info "Encryption key shared with the radius client";
              leaf cisco_enc {
                tailf:alt-name "7";
                tailf:info "RADIUS shared secret(encrypted)";
                type string {
                  tailf:info "WORD;;RADIUS shared secret(encrypted) (Max Size 63)";
                  length "1..63";
                }
              }
            }
          }
        }
      }
    }

    // aaa accounting
    container accounting {
      tailf:info "Configure accounting methods";
      tailf:cli-diff-dependency "/nx:aaa/group/server/tacacs-plus";
      tailf:cli-diff-dependency "/nx:aaa/group/server/radius";

      // aaa accounting default
      container default {
        tailf:info "Configure default methods";

        // aaa accounting default group
        leaf-list group {
          tailf:info "Specify server groups to redirect the accounting logs";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          tailf:cli-full-command;
          ordered-by user;
          type string {
            length "1..127";
          }
        }

        // aaa accounting default local
        leaf local {
          tailf:info "Use local accounting";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          default "true";
          type boolean;
        }
      }

      container dot1x {
        tailf:info "Accounting methods for dot1x";
        tailf:cli-diff-dependency "/nx:feature/dot1x";
        container default {
          tailf:info "Default aaa methods";
          leaf-list group {
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type string {
              tailf:info "WORD;;Server group name";
            }
          }
        }
      }

    }

    // aaa authentication
    container authentication {
      tailf:info "Configure authentication methods";
      tailf:cli-diff-dependency "/nx:aaa/accounting";
      tailf:cli-diff-dependency "/nx:aaa/group/server/tacacs-plus";
      tailf:cli-diff-dependency "/nx:aaa/group/server/radius";

      // aaa authentication login
      container login {
        tailf:info "Configure methods for login";

        // aaa authentication login ascii-authentication
        leaf ascii-authentication {
          tailf:info "Enable ascii authentication";
          tailf:cli-full-command;
          type empty;
        }

        // aaa authentication login chap
        leaf chap {
          tailf:info "CHAP authentication for login";
          tailf:cli-full-command;
          type enable-type;
        }

        container fallback-local {
          tailf:cli-drop-node-name;
          grouping fallback-grouping {
            container fallback {
              tailf:info "Configure fallback behavior";
              container error {
                tailf:info "Fallback in case all AAA servers configured for remote authentication are unreachable (Authentication error)";
                leaf local {
                  tailf:info "Fallback to local authentication";
                  tailf:cli-boolean-no;
                  default "true";
                  type boolean;
                }
              }
            }
          }
          container console {
            tailf:info "Configure console methods";
            uses fallback-grouping;
          }
          container default {
            tailf:info "Configure default methods";
            uses fallback-grouping;
          }
        }

        // aaa authentication login console
        container console {
          tailf:info "Configure console methods";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          uses groups-and-fallback-grouping;
        }

        // aaa authentication login default
        container default {
          tailf:info "Configure default methods";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          uses groups-and-fallback-grouping;
        }

        // aaa authentication mschap error-enable
        leaf error-enable {
          tailf:info "Enable display of error message on login failures";
          tailf:cli-full-command;
          type empty;
        }

        leaf invalid-username-log {
          tailf:info "Enable invalid username log";
          tailf:cli-full-command;
          type empty;
        }

        // aaa authentication mschap
        leaf mschap {
          tailf:info "MSCHAP authentication for login";
          tailf:cli-full-command;
          type enable-type;
        }

        // aaa authentication mschapv2
        leaf mschapv2 {
          tailf:info "MSCHAP V2 authentication for login";
          tailf:cli-full-command;
          type enable-type;
        }
      }

      // aaa authentication dot1x
      container dot1x {
        tailf:info "Authentication methods for dot1x";
        tailf:cli-diff-dependency "/nx:feature/dot1x";
        container default {
          tailf:info "Default aaa methods";
          leaf-list group {
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type string {
              tailf:info "WORD;;Server group name";
            }
          }
        }
      }

      // aaa authentication cts
      container cts {
        tailf:info "Authentication methods for cts";
        tailf:cli-diff-dependency "/nx:feature/cts";
        container default {
          tailf:info "Default aaa methods";
          leaf-list group {
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type string {
              tailf:info "WORD;;Server group name";
            }
          }
        }
      }

    }

    // aaa authorization
    container authorization {
      tailf:info "Configure authorization methods";
      tailf:cli-diff-dependency "/nx:aaa/accounting";
      tailf:cli-diff-dependency "/nx:aaa/group/server/tacacs-plus";
      tailf:cli-diff-dependency "/nx:aaa/group/server/radius";

      // aaa authorization commands
      container commands {
        tailf:info "Authorization for all exec-mode commands";
        tailf:cli-compact-syntax;

        // aaa authorization commands console
        container console {
          tailf:info "Configure methods console";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          uses groups-and-fallback-grouping;
        }

        // aaa authorization commands default
        container default {
          tailf:info "Configure default methods";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          uses groups-and-fallback-grouping;
        }
      }

      // aaa authorization config-commands
      container config-commands {
        tailf:info "Authorization for all exec-mode commands";
        tailf:cli-compact-syntax;

        // aaa authorization config-commands console
        container console {
          tailf:info "Configure methods console";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          uses groups-and-fallback-grouping;
        }

        // aaa authorization config-commands default
        container default {
          tailf:info "Configure default methods";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          uses groups-and-fallback-grouping;
        }
      }

      // aaa authorization ssh-certificate
      container ssh-certificate {
        tailf:info "Configure ssh certificate";

        // aaa authorization ssh-certificate
        container default {
          tailf:info "Configure default ssh methods";

          // aaa authorization ssh-certificate default group
          leaf group {
            tailf:info "Specify server groups";
            tailf:cli-diff-dependency "/nx:aaa/group/server/tacacs-plus/id";
            tailf:cli-full-command;
            type string {
              length "1..127";
            }
          }

          // aaa authorization ssh-certificate default local
          leaf local {
            tailf:info "Use local username authentication";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            default "true";
            type boolean;
          }
        }
      }

      // aaa authorization ssh-publickey
      container ssh-publickey {
        tailf:info "Configure ssh publickey";

        // aaa authorization ssh-publickey default
        container default {
          tailf:info "Configure default ssh methods";

          // aaa authorization ssh-publickey default group
          leaf group {
            tailf:info "Specify server groups";
            tailf:cli-diff-dependency "/nx:aaa/group/server/tacacs-plus/id";
            tailf:cli-full-command;
            type string {
              length "1..127";
            }
          }

          // aaa authorization ssh-publickey default local
          leaf local {
            tailf:info "Use local username authentication";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            default "true";
            type boolean;
          }
        }
      }

      // aaa authorization cts
      container cts {
        tailf:info "Authorization methods for cts";
        tailf:cli-diff-dependency "/nx:feature/cts";
        container default {
          tailf:info "Default aaa methods";
          leaf-list group {
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type string {
              tailf:info "WORD;;Server group name";
            }
          }
        }
      }

    }

    // aaa user
    container user {
      tailf:info "Remotely authenticated user";

      // aaa user default-role
      leaf default-role {
        tailf:info "Default role assigned by aaa-admin for remote"
          +" authentication";
        tailf:cli-full-command;
        type empty;
      }
    }
  }


  /// ========================================================================
  /// acllog
  /// ========================================================================

  container acllog {
    tailf:info "Configure ACL logging";
    leaf match-log-level {
      tailf:info "Acllog logging level";
      default 6;
      type uint8 {
        tailf:info "<0-7>;;Match log level";
      }
    }
  }


  /// ========================================================================
  /// segment
  /// ========================================================================

  container segment {
    tailf:cli-diff-dependency "/nx:feature/segmentation";
    when "/nx:feature/segmentation" {
      tailf:dependency "/nx:feature/segmentation";
    }

    // segment mode unicast-only
    container mode {
      leaf unicast-only {
        tailf:cli-boolean-no;
        default "false";
        type boolean;
      }
    }

    // segment control-protocol bgp
    container control-protocol {
      leaf bgp {
        tailf:cli-boolean-no;
        default "false";
        type boolean;
      }
    }
  }


  /// ========================================================================
  /// enable
  /// ========================================================================

  container enable {
    tailf:info "Create secret for privilege escalation";
    container secret {
      tailf:info "Create secret for privilege escalation (defaults to highest priv-lvl 14/15)";
      tailf:cli-diff-dependency "/nx:feature/privilege";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf "type" {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        nx:device-transformed-dependency;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "5" {
            tailf:info "Specifies an ENCRYPTED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        nx:device-transformed-value;
        type string {
          tailf:info "WORD;;Secret for privilege escalation";
          length "1..64";
        }
      }
    }
  }


  /// ========================================================================
  /// cfs
  /// ========================================================================

  container cfs {
    tailf:info "CFS configuration commands";
    leaf distribute {
      tailf:info "Enable fabric wide distribution";
      type empty;
    }
    container eth {
      tailf:info "ETH configurations";
      leaf distribute {
        tailf:info "Enable CFS distribution over Ethernet";
        tailf:cli-diff-set-before "/nx:feature/vpc";
        type empty;
      }
    }
    container ipv4 {
      tailf:info "IPv4 configurations";
      leaf distribute {
        tailf:info "Enable CFS distribution over IPv4";
        type empty;
      }
      leaf mcast-address {
        tailf:info "Configure IPv4 multicast address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Admin scope [239.255/16, 239.192/16-239.251/16]";
        }
      }
    }
    leaf region {
      tailf:info "Regions to limit the distribution scope of application(s)";
      type uint8 {
        tailf:info ";;<1-200>  Region Id";
        range "1..200";
      }
    }
    leaf static-peers {
      tailf:info "Enable Static peers configuration mode";
      type empty;
    }
  }


  /// ========================================================================
  /// cts
  /// ========================================================================

  container cts {
    tailf:info "Config commands for CTS";
    tailf:cli-diff-dependency "/nx:feature/cts";

    container cache {
      tailf:info "Enable Caching of Environment Data downloaded from AAA";
      leaf enable {
        type empty;
      }
    }

    container device-id {
      tailf:info "Device-id used during EAP FAST";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;

      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Name";
        }
      }

      container password {
        tailf:info "Password used during EAP FAST";
        tailf:cli-flatten-container;
        choice pwd-type-choice {
          leaf cisco_enc {
            tailf:info "Enter encypted password used during EAP FAST";
            tailf:alt-name "7";
            type string {
              tailf:info "WORD;;Encrypted password";
            }
          }
          leaf clear {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Clear text password";
            }
          }
        }
      }
    }

    // cts role-based
    container role-based {
      tailf:info "Configure RBACL policies";

      container counters {
        tailf:info "RBACL policy counters";
        leaf enable {
          tailf:info "Enable counters per RBACL policy";
          type empty;
        }
      }

      list sgt-map {
        tailf:info "Configure IP Address to SGT mapping";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key addr;
        leaf addr {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP Address in format A.B.C.D";
            }
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/LEN;;IPv4 Prefix";
            }
          }
        }

        leaf sgt {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65519>;;SGT corresponding to the IP Address";
          }
        }
      }

      leaf enforcement {
        tailf:info "Enable RBACL enforcement";
        type empty;
      }
    }

    // cts sgt
    leaf sgt {
      tailf:info "SGT tag for pkts from this device";
      type string {
        tailf:info "<2-65519>;;Sgt value input as decimal or hex. Allowed hex range <0x2-0xffef>";
        pattern "0x[0-9A-F]+";
      }
    }

    // cts sxp
    container sxp {
      tailf:info "Supply configuration for SXP parameters";
      leaf enable {
        tailf:info "Enable SXP";
        type empty;
      }
      container default {
        tailf:info "Default SXP password";
        container password {
          tailf:info "SXP password";
          choice pwd-type-choice {
            leaf cisco_enc {
              tailf:info "Provide encrypted default SXP password";
              tailf:alt-name "7";
              type string {
                tailf:info "WORD;;Encrypted default SXP password";
              }
            }
            leaf clear {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;SXP password";
              }
            }
          }
        }
        leaf source-ip {
          tailf:info "Source IP Address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Address in format A.B.C.D";
          }
        }
      }
      container connection {
        tailf:info "Configuration for SXP connection";
        list peer {
          tailf:info "Configuration for peer";
          tailf:cli-suppress-mode;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          key "addr vrf";

          leaf addr {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP Address in format A.B.C.D";
            }
          }

          leaf source {
            tailf:cli-optional-in-sequence;
            tailf:cli-prefix-key {
              tailf:cli-before-key "2";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP Address in format A.B.C.D";
            }
          }

          leaf password {
            tailf:info "SXP password configuration";
            tailf:cli-prefix-key {
              tailf:cli-before-key "2";
            }
            type enumeration {
              enum default {
                tailf:info "Use default password";
              }
              enum none {
                tailf:info "Dont use any password";
              }
              enum required {
                tailf:info "Provide the password to be used with the SXP peer";
              }
            }
          }

          leaf cisco_enc {
            tailf:info "Provide encrypted password for SXP peer";
            tailf:cli-optional-in-sequence;
            tailf:cli-prefix-key {
              tailf:cli-before-key "2";
            }
            when "../password = 'required'" {
              tailf:dependency "../password";
            }
            tailf:alt-name "7";
            type string {
              tailf:info "WORD;;Encrypted password for SXP peer";
            }
          }

          leaf mode {
            tailf:info "SXP mode";
            tailf:cli-prefix-key {
              tailf:cli-before-key "2";
            }
            type enumeration {
              enum listener {
                tailf:info "SXP listener";
              }
              enum speaker {
                tailf:info "SXP speaker";
              }
            }
          }

          leaf vrf {
            tailf:cli-expose-key-name;
            tailf:non-strict-leafref {
              path "/nx:vrf/context/id";
            }
            type vrf-member-type;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// username
  /// ========================================================================


  list username {
    tailf:info "Establish User Name Authentication";
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands {
      tailf:cli-reset-siblings;
    }
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;User name";
      }
    }

    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-compact-syntax;
      tailf:cli-flatten-container;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        nx:device-transformed-dependency;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "5" {
            tailf:info "Specifies a HIDDEN password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "5|0";
        nx:device-transformed-value;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;The HIDDEN user password string";
        }
      }
    }

    leaf expire {
      tailf:info "Expiry date for this user account(in YYYY-MM-DD format)";
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;Expiry in YYYY-MM-DD format (Max Size 10)";
      }
    }

    leaf role {
      tailf:info "Role which the user is to be assigned to";
      tailf:non-strict-leafref {
        path "/nx:role/name/name";
      }
      type user-role-type;
    }
  }

  // username * role
  container username-secondary-roles {
    tailf:cli-drop-node-name;
    list username {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-create-after "/nx:snmp-server/user" {
        tailf:cli-when-target-create;
      }
      key "name role";
      leaf name {
        tailf:non-strict-leafref {
          path "/nx:username/name";
        }
        type string {
          tailf:info "WORD;;User name";
        }
      }
      leaf role {
        tailf:cli-expose-key-name;
        tailf:non-strict-leafref {
          path "/nx:role/name/name";
        }
        type user-role-type;
      }
    }
  }

  container username-config {
    tailf:cli-drop-node-name;
    list username {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:non-strict-leafref {
          path "/nx:username/name";
        }
        type string {
          tailf:info "WORD;;User name";
        }
      }

      container sshkey {
        tailf:info "Update ssh key for the user for ssh authentication";
        leaf file {
          tailf:info "Ssh key file";
          type string;
        }
        leaf openssh-key {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Ssh key for the user";
          }
        }
      }

      container passphrase {
        tailf:info "User passphrase";
        tailf:cli-compact-syntax;
        leaf gracetime {
          tailf:info "User passphrase gracetime";
          type uint32 {
            tailf:info "<0-99999>;;Grace period of passphrase (in days)";
            range "0..99999";
          }
        }
        leaf lifetime {
          tailf:info "User passphrase lifetime";
          type uint32 {
            tailf:info "<0-99999>;;Lifetime of passphrase (in days)";
            range "0..99999";
          }
        }
        leaf warntime {
          tailf:info "User passphrase warningtime";
          type uint32 {
            tailf:info "<0-99999>;;Warning period of passphrase (in days)";
            range "0..99999";
          }
        }
      }

      container keypair {
        container generate {
          leaf rsa {
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// nxapi
  /// ========================================================================

  container nxapi {
    tailf:info "Configure nxapi";
    tailf:cli-diff-dependency "/nx:feature/nxapi";

    container http {
      tailf:info "Http configuration";
      leaf port {
        tailf:info "Port number";
        default 80;
        type uint16 {
          tailf:info "<1-65535>;;Port number. Please do not use well-known protocol ports";
        }
      }
    }

    container https {
      tailf:info "Https configuration";
      leaf port {
        tailf:info "Port number";
        default 443;
        type uint16 {
          tailf:info "<1-65535>;;Port number. Please do not use well-known protocol ports";
        }
      }
    }

    leaf use-vrf {
      tailf:info "Vrf to be used for nxapi communication";
      tailf:non-strict-leafref {
        path "/nx:vrf/context/id";
      }
      type vrf-member-type;
    }
  }


  /// ========================================================================
  /// banner
  /// ========================================================================

  container banner {
    tailf:info "Define a login banner";

    grouping banner-body-grouping {
      leaf start-marker {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        type string;
      }
      leaf message {
        tailf:cli-drop-node-name;
        tailf:cli-multi-line-prompt;
        tailf:cli-no-value-on-delete;
        type string;
      }
      leaf end-marker {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        type string;
        must "../end-marker = ../start-marker" {
          tailf:dependency "../end-marker";
          tailf:dependency "../start-marker";
        }
      }
    }

    container exec {
      tailf:info "Set EXEC process creation banner";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;

      uses banner-body-grouping;
    }

    container motd {
      tailf:info "Set Message of the Day banner";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;

      uses banner-body-grouping;
    }
  }


  /// ========================================================================
  /// ssh
  /// ========================================================================

  container ssh {
    tailf:info "Configure SSH parameters";
    container key {
      tailf:info "Generate SSH Key";
      leaf rsa {
        type uint16;
      }
    }

    leaf login-attempts {
      tailf:info "Set maximum login attempts from ssh";
      default 3;
      type uint8 {
        tailf:info "<1-10>;;Specify max-attempt number";
      }
    }
  }


  /// ========================================================================
  /// fabric
  /// ========================================================================
  container fabric {
    tailf:info "Fabric";
    container forwarding {
      tailf:info "Forwarding.";
      leaf anycast-gateway-mac {
        tailf:info "MAC";
        tailf:cli-diff-delete-before "/nx:feature/fabric/forwarding";
        tailf:cli-diff-delete-before "/nx:nv/overlay/evpn";
        tailf:cli-diff-delete-after "/nx:interface/Vlan/fabric/forwarding/mode";
        type string;
      }
    }
  }


  /// ========================================================================
  /// fabricpath
  /// ========================================================================
  container fabricpath {
    tailf:info "Fabricpath configuration";
    // fabricpath domain
    container domain {
      tailf:info "Enter fabricpath IS-IS domain configuration mode";
      // fabricpath domain default
      container default {
        tailf:info "Default fabricpath domain";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-fabricpath-isis";
        tailf:cli-diff-dependency "/nx:feature-set/fabricpath" {
          tailf:cli-trigger-on-set;
        }
        presence "true";
        nx:delete-with "none";
        // fabricpath domain default / spf-interval
        container spf-interval {
          tailf:info "Configure SPF interval";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          uses isis-spf-interval-grouping;
        }
        // fabricpath domain default / lsp-gen-interval
        container lsp-gen-interval {
          tailf:info "Configure LSP generation interval";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          uses isis-lsp-gen-interval-grouping;
        }
        // fabricpath domain default / root-priority
        leaf root-priority {
          tailf:info "Set priority with which nodes becomes root";
          type uint8 {
            tailf:info "<1-255>;;Root priority value per topology";
            range "1..255";
          }
        }

        // fabricpath domain default / set-overload-bit
        container set-overload-bit {
          tailf:info "Signal other routers not to use us for transit";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          choice always-or-startup-choice {
            leaf always {
              tailf:info "Set the overload bit unconditionally";
              type empty;
            }
            leaf on-startup {
              tailf:info "Set the overload bit on IS-IS startup";
              type uint32 {
                tailf:info "<5-86400>;;Clear the overload bit after an elapsed time in seconds";
              }
            }
          }
        }
        container fabricpath {
          tailf:info "Configure fabricpath global commands";
          container isis {
            tailf:info "Fabricpath IS-IS global commands";
            list event-history {
              tailf:info "Configure event-history buffers";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key event;
              leaf event {
                type enumeration {
                  enum adjacency { tailf:info "Adjacency events"; }
                  enum cli { tailf:info "CLI events"; }
                  enum csnp { tailf:info "CSNP events"; }
                  enum drap { tailf:info "DRAP events"; }
                  enum events { tailf:info "Message and high-level events"; }
                  enum graceful { tailf:info "Graceful Restart events"; }
                  enum ha { tailf:info "High-Availability events"; }
                  enum iih { tailf:info "Interface hello events"; }
                  enum lsp-flood { tailf:info "LSP-flood events"; }
                  enum lsp-gen { tailf:info "LSP-Gen events"; }
                  enum m2rib { tailf:info "M2rib events"; }
                  enum mccast { tailf:info "Mccast events"; }
                  enum psnp { tailf:info "PSNP events"; }
                  enum redist { tailf:info "Redistribution events"; }
                  enum spf-leaf { tailf:info "Shortest path first events"; }
                  enum spf-tree { tailf:info "SPF-Tree events"; }
                  enum urib { tailf:info "URIB events"; }
                }
              }
              leaf size {
                tailf:info "Configure size";
                type union {
                  type enumeration {
                    enum disabled { tailf:info "Disabled"; }
                    enum large { tailf:info "Large buffer"; }
                    enum medium { tailf:info "Medium buffer"; }
                    enum small { tailf:info "Small buffer"; }
                  }
                  type uint32;
                }
              }
            }
          }
        }

        container address-family {
          container ipv4 {
            container unicast {
              presence true;
            }
          }
          container ipv6 {
            container unicast {
              presence true;
            }
          }
        }

        list topology {
          tailf:info "Configure Layer-2 Topology for IS-IS";
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-63>;;L2 Topology ID 1-63";
            }
          }
          leaf maximum-paths {
            tailf:info "Set maximum paths per destination";
            default 16;
            type uint8 {
              tailf:info "<1-16>;;Maximum paths per destination";
            }
          }
          container reference-bandwidth {
            tailf:info "Change reference bandwidth used for setting interface metric";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf value {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-4000000>;;Bandwidth in Mbps/Gbps (default)";
              }
            }
            leaf Mbps {
              tailf:info "Specify in Mbps";
              type empty;
            }
          }
          leaf root-priority {
            tailf:info "Set priority with which nodes becomes root";
            default 64;
            type uint8 {
              tailf:info "<1-255>;;Root priority value per topology";
            }
          }
        }
      }
    }
    // fabricpath graceful-merge
    container graceful-merge {
      tailf:info "Graceful merging of netwoks";
      // fabricpath graceful-merge disable
      leaf disable {
        tailf:info "Disable graceful merge of networks";
        type empty;
      }
    }
    // Skip: fabricpath linkup-delay
    // Skip: fabricpath load-balance
    // fabricpath mode
    container mode {
      tailf:info "Mode";
      // fabricpath mode transit
      leaf transit {
        tailf:info "Enable this system to switch traffic based on switch_id wit"
          +"h no segmentation support";
        type empty;
      }
    }
    // Skip: fabricpath multicast
    // Skip: fabricpath oam
    // Skip: fabricpath route
    // fabricpath switch-id
    leaf switch-id {
      tailf:info "Statically configured switch-id";
      type uint16 {
        tailf:info "<1-4094>;;Switch-id-value";
        range "1..4094";
      }
    }
    // fabricpath timers
    container timers {
      tailf:info "Fabricpath switch-id timers";
      // Skip: allocate-delay    Time delay new resource propagation
      leaf linkup-delay {
        tailf:info "Time delay for link bringup for detecting conflicts";
        type union {
          type uint16 {
            tailf:info "<1-1200>;;Timer value in seconds";
            range "1..1200";
          }
          type enumeration {
            enum always {
              tailf:info "This will always enforce the link-up delay for all co"
              +"re ports. The default behavior does not use the timer in know"
              +"n networks to optimize link bring-up.";
            }
          }
        }
      }
      // Skip: transition-delay  Time delay transitiond value propagation
    }

    // Skip: fabricpath topology
    // fabricpath ttl
    container ttl {
      tailf:info "Configure TTL value";
      // fabricpath ttl multicast
      leaf multicast {
        tailf:info "Configure multicast TTL value";
        tailf:cli-no-value-on-delete;
        type uint8 {
          tailf:info "1-64;;Value of TTL in number of hops. Default is 32.";
          range "1..64";
        }
      }
      // fabricpath ttl unicast
      leaf unicast {
        tailf:info "Configure unicast TTL value";
        tailf:cli-no-value-on-delete;
        type uint8 {
          tailf:info "1-64;;Value of TTL in number of hops. Default is 32.";
          range "1..64";
        }
      }
    }
  }


  /// ========================================================================
  /// ip
  /// ========================================================================

  container ip {
    tailf:info "Configure IP features";

    // ip as-path
    container as-path {
      tailf:info "BGP autonomous system path filter";
      list access-list {
        tailf:info "Specify an access list name";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;AS path access list name (Max Size 63)";
            length "1..63";
          }
        }
        list seq {
          tailf:info "Sequence number of an entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key num;
          leaf num {
            tailf:cli-diff-delete-before "../../seq/num" {
              tailf:cli-when-target-set;
            }
            type uint32 {
              tailf:info "<1-4294967294>;;Sequence number";
            }
          }
          leaf action {
            tailf:cli-drop-node-name;
            type enumeration {
              enum deny { tailf:info "Specify packets to reject"; }
              enum permit { tailf:info "Specify packets to forward"; }
            }
          }
          leaf regex {
            tailf:cli-drop-node-name;
            nx:escape-questionmark;
            type string {
              tailf:info "LINE;;A regular-expression to match BGP AS paths. Use \"ctrl-v ?\" to enter \"?\". (Max Size 63)";
            }
          }
        }
        list unsequenced {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key regex;
          leaf regex {
            nx:escape-questionmark;
            type string {
              tailf:info "LINE;;A regular-expression to match BGP AS paths. (Max Size 63)";
            }
          }
          leaf action {
            tailf:cli-prefix-key;
            tailf:cli-drop-node-name;
            type enumeration {
              enum deny { tailf:info "Specify packets to reject"; }
              enum permit { tailf:info "Specify packets to forward"; }
            }
          }
        }
      }
    }

    // ip community-list
    container community-list {
      tailf:info "Add a community list entry";
      list standard {
        tailf:info "Add a standard Community list entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Standard community list name (Max Size 63)";
            length "1..63";
          }
        }
        choice entry-syntax-choice {
          list entry {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            ordered-by user;
            key community-spec;
            leaf community-spec {
              tailf:cli-multi-word-key;
              type string {
                tailf:info "<internet> <local-AS> <no-advertise> <no-export> <ASN2:NN>";
                pattern "(internet|local-AS|no-advertise|no-export|([0-9]+:[0-9]+))( (internet|local-AS|no-advertise|no-export|([0-9]+:[0-9]+)))*";
              }
            }
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              mandatory true;
              type enumeration {
                enum deny {
                  tailf:info "Specify community to reject";
                }
                enum permit {
                  tailf:info "Specify community to accept";
                }
              }
            }
          }
          list seq-entry {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key seq;
            leaf seq {
              tailf:cli-expose-key-name;
              tailf:cli-diff-delete-before "../../seq-entry/seq";
              type uint32 {
                tailf:info "<1-4294967294>;;Sequence number";
              }
            }
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              tailf:cli-remove-before-change;
              mandatory true;
              type enumeration {
                enum deny {
                  tailf:info "Specify community to reject";
                }
                enum permit {
                  tailf:info "Specify community to accept";
                }
              }
            }
            leaf-list community {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              type union {
                type enumeration {
                  enum internet {
                    tailf:info "Internet (well-known community)";
                  }
                  enum local-AS {
                    tailf:info "Do not send outside local AS (well-known community)";
                  }
                  enum no-advertise {
                    tailf:info "Do not advertise to any peer (well-known community)";
                  }
                  enum no-export {
                    tailf:info "Do not export to next AS (well-known community)";
                  }
                }
                type string {
                  tailf:info "ASN2:NN;;Community number aa:nn format";
                  pattern "[0-9]+:[0-9]+";
                }
              }
            }
          }
        }
      }
      list expanded {
        tailf:info "Add an expanded community list entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of expanded community list (Max Size 63)";
            length "1..63";
          }
        }
        choice entry-syntax-choice {
          list entry {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            ordered-by user;
            key regexp;
            leaf regexp {
              tailf:cli-multi-word-key;
              tailf:cli-disallow-value "seq [0-9]+.*";
              type string {
                tailf:info "LINE;;Regular-expression(must use aa:nn format). (Max Size 63)";
                length "1..63";
              }
            }
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              mandatory true;
              type enumeration {
                enum deny {
                  tailf:info "Specify community to reject";
                }
                enum permit {
                  tailf:info "Specify community to accept";
                }
              }
            }
          }
          list seq-entry {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key seq;
            leaf seq {
              tailf:cli-expose-key-name;
              type uint32 {
                tailf:info "<1-4294967294>;;Sequence number";
              }
            }
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              mandatory true;
              type enumeration {
                enum deny {
                  tailf:info "Specify community to reject";
                }
                enum permit {
                  tailf:info "Specify community to accept";
                }
              }
            }
            leaf regexp {
              tailf:cli-multi-value;
              tailf:cli-drop-node-name;
              type string {
                tailf:info "LINE;;Regular-expression(must use aa:nn format). (Max Size 63)";
                length "1..63";
              }
            }
          }
        }
      }
    }

    container extcommunity-list {
      tailf:info "Add a extcommunity list entry";
      list expanded {
        tailf:info "Add an expanded extcommunity list entry";
        tailf:cli-suppress-mode;
        key "name regex";
        leaf name {
          type string {
            tailf:info "WORD;;Name of expanded extcommunity list (Max Size 63)";
          }
        }
        leaf perm {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key {
            tailf:cli-before-key "2";
          }
          type enumeration {
            enum deny {
              tailf:info "Specify extcommunity to reject";
            }
            enum permit {
              tailf:info "Specify extcommunity to accept";
            }
          }
        }
        leaf regex {
          nx:escape-questionmark;
          type string {
            tailf:info "LINE;;Regular-expression(must use aa:nn format). Use 'ctrl-v ?' to enter '?'. (Max Size 63)";
          }
        }
      }

      list standard {
        tailf:info "Add a standard Extcommunity list entry";
        tailf:cli-suppress-mode;
        key "name spec";
        leaf name {
          type string {
            tailf:info "WORD;;Standard extcommunity list name (Max Size 63)";
          }
        }
        leaf perm {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key {
            tailf:cli-before-key "2";
          }
          type enumeration {
            enum deny {
              tailf:info "Specify extcommunity to reject";
            }
            enum permit {
              tailf:info "Specify extcommunity to accept";
            }
          }
        }
        leaf spec {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "4byteas-generic|rt|soo <value> pairs as entered on device";
          }
        }
      }
    }

    // ip dhcp
    container dhcp {
      tailf:info "Configure DHCP snooping and relay";
      when "../../feature/dhcp" {
        tailf:dependency "../../feature/dhcp";
      }
      tailf:cli-diff-dependency "/nx:feature/dhcp";
      leaf relay {
        tailf:cli-show-with-default;
        tailf:cli-full-command;
        default true;
        tailf:cli-boolean-no;
        type boolean;
      }
      container relay-config {
        tailf:cli-drop-node-name;
        container relay {
          tailf:cli-incomplete-command;
          // ip dhcp relay information
          container information {
            tailf:info "Relay agent information option";
            container option {
              tailf:info "Insert relay information in BOOTREQUEST";
              presence true;
              tailf:cli-display-separated;
              leaf vpn {
                tailf:info "Enable relay support across VRFs";
                type empty;
              }
              leaf trust {
                tailf:info "Enable relay trust functionality on the system";
                type empty;
              }
            }
            leaf trust-all {
              tailf:info "Enable relay trust on all the interfaces";
              type empty;
            }
          }
          // ip dhcp relay sub-option
          container sub-option {
            tailf:info "Relay agent suboption";
            container type {
              tailf:info "Relay agent suboption type";
              leaf cisco {
                tailf:info "Use Cisco propritery suboptions";
                type empty;
              }
            }
          }
        }
      }
      // ip dhcp snooping
      leaf snooping {
        tailf:cli-full-command;
        type empty;
      }
      container snooping-config {
        tailf:cli-drop-node-name;
        container snooping {
          tailf:cli-incomplete-command;
          // dhcp snooping information
          container information {
            tailf:info "DHCP Snooping information";
            leaf option {
              tailf:info "DHCP Snooping information option";
              tailf:cli-full-command;
              type empty;
            }
          }
          // ip dhcp snooping verify
          container verify {
            tailf:info "DHCP snooping verify";
            leaf mac-address {
              tailf:info "DHCP snooping verify mac-address";
              tailf:cli-boolean-no;
              default true;
              type boolean;
            }
          }
          // ip dhcp snooping vlan
          list vlan {
            tailf:info "DHCP Snooping vlan";
            tailf:cli-suppress-mode;
            tailf:cli-range-list-syntax;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-3967,4048-4093>;;VLAN ID 1-4094 or "
                  +"range(s): 1-5, 10 or 2-5,7-19";
                range "1..4096";
              }
            }
          }
        }
      }
      // ip dhcp smart-relay
      container smart-relay {
        tailf:info "Configure DHCP smart relay";
        leaf global {
          tailf:info "Configure DHCP smart relay globally";
          type empty;
        }
      }
      // ip dhcp packet
      container packet {
        tailf:info "DHCP packet";
        leaf strict-validation {
          tailf:info "DHCP packet strict validation";
          type empty;
        }
      }
    }

    // ip dns
    container dns {
      tailf:info "Configure dns client";
      tailf:cli-diff-dependency "/nx:interface";
      // Workaround for strange behaviour: dns is returned as domain-lookup

      // ip dns source-interface
      list source-interface {
        tailf:cli-suppress-mode;
        key vrf;
        leaf vrf {
          tailf:cli-expose-key-name;
          tailf:key-default "default";
          tailf:non-strict-leafref {
            path "/nx:vrf/context/id";
          }
          type vrf-member-type;
        }
        leaf interface-name {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:info "Configure source interface feature for domain-lookup";
          nx:case-insensitive-type;
          type string {
            pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
      }
    }

    // ip ftp
    container ftp {
      tailf:info "Configure FTP client";
      tailf:cli-diff-dependency "/nx:interface";
      list source-interface {
        tailf:cli-suppress-mode;
        key vrf;
        leaf vrf {
          tailf:cli-expose-key-name;
          tailf:key-default "default";
          tailf:non-strict-leafref {
            path "/nx:vrf/context/id";
          }
          type vrf-member-type;
        }
        leaf interface-name {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:info "Configure source interface feature for FTP client";
          nx:case-insensitive-type;
          type string {
            pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
      }
    }

    // ip telnet
    container telnet {
      tailf:info "Configure telnet client";
      tailf:cli-diff-dependency "/nx:interface";
      // ip tftp source-interface
      list source-interface {
        tailf:cli-suppress-mode;
        key vrf;
        leaf vrf {
          tailf:cli-expose-key-name;
          tailf:key-default "default";
          tailf:non-strict-leafref {
            path "/nx:vrf/context/id";
          }
          type vrf-member-type;
        }
        leaf interface-name {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:info "Configure source interface feature for telnet client";
          nx:case-insensitive-type;
          type string {
            pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
      }
    }

    // ip tftp
    container tftp {
      tailf:info "Configure TFTP client";
      tailf:cli-diff-dependency "/nx:interface";
      // ip tftp source-interface
      list source-interface {
        tailf:cli-suppress-mode;
        key vrf;
        leaf vrf {
          tailf:cli-expose-key-name;
          tailf:key-default "default";
          tailf:non-strict-leafref {
            path "/nx:vrf/context/id";
          }
          type vrf-member-type;
        }
        leaf interface-name {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:info "Configure source interface feature for TFTP client";
          nx:case-insensitive-type;
          type string {
            pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
      }
    }

    // ip access-list
    container access-list {
      tailf:info "Configure access list";

      // ip access-list match-local-traffic
      leaf match-local-traffic {
        tailf:info "Enable access-list matching for locally generated traffic";
        tailf:cli-full-command;
        type empty;
      }

      // ip access-list *
      list list-name {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-acl";
        tailf:cli-full-command;
        key id;
        leaf id {
          tailf:cli-disallow-value "match-local-traffic";
          type string {
            tailf:info "WORD;;List name (Max Size 64)";
            length "1..64";
          }
        }

        uses ip-access-list-common-grouping;

        // ip access-list * / *
        list sequence {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-4294967295>;;Sequence number";
              range "1..4294967295";
            }
          }

          leaf action {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum "deny" {
                tailf:info "Specify packets to reject";
              }
              enum "permit" {
                tailf:info "Specify packets to forward";
              }
              enum "remark" {
                tailf:info "Access list entry comment";
              }
            }
          }

          uses ip-access-list-grouping {
            when "action != 'remark'";
          }

          leaf remark-value {
            tailf:cli-multi-value;
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            when "../action = 'remark'";
            type string {
              tailf:info "LINE;;Comment, up to 100 characters (Max Size 100)";
              length "1..100";
            }
          }
        }
      }
    }

